{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.22;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC-1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.22;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/aave/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IAaveOracle {\n    function getAssetPrice(address _asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/aave/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IIncentivesController} from \"./IIncentivesController.sol\";\n\ninterface IAToken is IERC20 {\n    /**\n     * @dev Returns the address of the incentives controller contract\n     **/\n    function getIncentivesController() external view returns (IIncentivesController);\n\n    function mint(address user, uint256 amount, uint256 index) external returns (bool);\n\n    function burn(address user, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n    //solhint-disable func-name-mixedcase\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/aave/IIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IIncentivesController {\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    function claimRewards(address[] calldata assets, uint256 amount, address to) external returns (uint256);\n\n    function claimAllRewards(\n        address[] calldata assets,\n        address to\n    ) external returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    function getRewardsList() external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface ILendingPool {\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf) external;\n\n    function getUserAccountData(\n        address _user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n}\n"
    },
    "contracts/interfaces/aave/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {ILendingPool} from \"./ILendingPool.sol\";\nimport {IAaveOracle} from \"./IAaveOracle.sol\";\nimport {IProtocolDataProvider} from \"./IProtocolDataProvider.sol\";\n\ninterface IPoolAddressesProvider {\n    function getPool() external view returns (ILendingPool);\n\n    function getPoolDataProvider() external view returns (IProtocolDataProvider);\n\n    function getPriceOracle() external view returns (IAaveOracle);\n}\n"
    },
    "contracts/interfaces/aave/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IProtocolDataProvider {\n    function getReserveTokensAddresses(\n        address asset\n    ) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\n\n    function getReserveData(\n        address asset\n    )\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getReserveConfigurationData(\n        address asset\n    )\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n}\n"
    },
    "contracts/interfaces/aave/IStakedAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n//solhint-disable func-name-mixedcase\ninterface IStakedAave is IERC20 {\n    function claimRewards(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function stake(address onBehalfOf, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function getTotalRewardsBalance(address staker) external view returns (uint256);\n\n    function stakersCooldowns(address staker) external view returns (uint256);\n\n    function COOLDOWN_SECONDS() external view returns (uint256);\n\n    function UNSTAKE_WINDOW() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/interfaces/compound/IComet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IComet is IERC20 {\n    struct AssetInfo {\n        uint8 offset;\n        address asset;\n        address priceFeed;\n        uint64 scale;\n        uint64 borrowCollateralFactor;\n        uint64 liquidateCollateralFactor;\n        uint64 liquidationFactor;\n        uint128 supplyCap;\n    }\n\n    struct TotalsCollateral {\n        uint128 totalSupplyAsset;\n        uint128 _reserved;\n    }\n\n    /// @notice The address of the base token contract\n    function baseToken() external view returns (address);\n\n    /// @notice The address of the price feed for the base token\n    function baseTokenPriceFeed() external view returns (address);\n\n    /**\n     * @notice Query the current negative base balance of an account or zero\n     * @dev Note: uses updated interest indices to calculate\n     * @param account The account whose balance to query\n     * @return The present day base balance magnitude of the account, if negative\n     */\n    function borrowBalanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice Query the current collateral balance of an account\n     * @param account The account whose balance to query\n     * @param asset The collateral asset to check the balance for\n     * @return The collateral balance of the account\n     */\n    function collateralBalanceOf(address account, address asset) external view returns (uint128);\n\n    /**\n     * @dev Determine index of asset that matches given address and return assetInfo\n     */\n    function getAssetInfoByAddress(address asset) external view returns (AssetInfo memory);\n\n    /**\n     * @notice Get the current price from a feed\n     * @param priceFeed The address of a price feed\n     * @return The price, scaled by `PRICE_SCALE`\n     */\n    function getPrice(address priceFeed) external view returns (uint256);\n\n    /**\n     * @notice Get the total amount of debt\n     * @dev Note: uses updated interest indices to calculate\n     * @return The amount of debt\n     **/\n    function totalBorrow() external view returns (uint256);\n\n    /**\n     * @notice Get the total amount of given token\n     * @param asset The collateral asset to check the total for\n     * @return The total collateral balance\n     */\n    function totalsCollateral(address asset) external view returns (TotalsCollateral memory);\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @dev Note: uses updated interest indices to calculate\n     * @return The supply of tokens\n     **/\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Supply an amount of asset to the protocol\n     * @param asset The asset to supply\n     * @param amount The quantity to supply\n     */\n    function supply(address asset, uint256 amount) external;\n\n    /**\n     * @notice Withdraw an amount of asset from the protocol\n     * @param asset The asset to withdraw\n     * @param amount The quantity to withdraw\n     */\n    function withdraw(address asset, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/compound/IRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IRewards {\n    struct RewardOwed {\n        address token;\n        uint256 owed;\n    }\n\n    /**\n     * @notice Calculates the amount of a reward token owed to an account\n     * @param comet The protocol instance\n     * @param account The account to check rewards for\n     */\n    function getRewardOwed(address comet, address account) external returns (RewardOwed memory);\n\n    /**\n     * @notice Claim rewards of token type from a comet instance to owner address\n     * @param comet The protocol instance\n     * @param src The owner to claim for\n     * @param shouldAccrue Whether or not to call accrue first\n     */\n    function claim(address comet, address src, bool shouldAccrue) external;\n}\n"
    },
    "contracts/interfaces/convex/IConvexForCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IConvex {\n    function poolInfo(uint256) external view returns (address, address, address, address, address, bool);\n\n    // deposit lp tokens and stake\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns (bool);\n\n    // deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\n\n    // withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    // withdraw all lp tokens\n    function withdrawAll(uint256 _pid) external returns (bool);\n\n    // claim crv + extra rewards\n    function earmarkRewards(uint256 _pid) external returns (bool);\n\n    // claim  rewards on stash (msg.sender == stash)\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool);\n\n    // delegate address votes on dao (needs to be voteDelegate)\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns (bool);\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight) external returns (bool);\n}\n\ninterface IRewards {\n    function pid() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function extraRewards(uint256) external view returns (address);\n\n    function periodFinish() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function rewardPerTokenStored() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function rewards(address) external view returns (uint256);\n\n    function userRewardPerTokenPaid(address) external view returns (uint256);\n\n    function stakingToken() external view returns (address);\n\n    function stake(uint256) external returns (bool);\n\n    function stakeAll() external returns (bool);\n\n    function stakeFor(address, uint256) external returns (bool);\n\n    function withdraw(uint256 amount, bool claim) external returns (bool);\n\n    function withdrawAll(bool claim) external returns (bool);\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\n\n    function withdrawAllAndUnwrap(bool claim) external;\n\n    function getReward() external returns (bool);\n\n    function getReward(address _account, bool _claimExtras) external returns (bool);\n\n    function donate(uint256 _amount) external returns (bool);\n\n    function queuedRewards() external view returns (uint256);\n}\n\ninterface IStashTokenWrapper {\n    function token() external view returns (address);\n}\n"
    },
    "contracts/interfaces/curve/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.8.25;\n\ninterface IAddressProvider {\n    function get_registry() external view returns (address);\n\n    function get_address(uint256 i) external view returns (address);\n}\n"
    },
    "contracts/interfaces/curve/ICurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.8.25;\n\ninterface IDepositAndStake {\n    /**\n     * @notice Deposit coins into Curve pool and stake LP tokens into a Curve gauge.\n     * @param deposit Address of the deposit contract. It can be Curve pool or zap.\n     * @param lpToken Address of the LP token.\n     * @param gauge Address of the gauge.\n     * @param nCoins Number of coins in the pool.\n     * @param coins Array of coin addresses.\n     * @param amounts Array of amounts to deposit for each coin.\n     * @param minMintAmount Minimum amount of LP tokens to mint.\n     * @param useUnderlying Boolean indicating whether to use underlying tokens.\n     * @param useDynArray Boolean indicating whether to use dynamic arrays.\n     * @param pool It can be null. If zap contract is used as 'deposit' then it will be address of the curve pool.\n     */\n    function deposit_and_stake(\n        address deposit,\n        address lpToken,\n        address gauge,\n        uint256 nCoins,\n        address[] calldata coins,\n        uint256[] calldata amounts,\n        uint256 minMintAmount,\n        bool useUnderlying,\n        bool useDynArray,\n        address pool\n    ) external payable;\n}\n\ninterface IWithdraw {\n    // Calculate collateral out if remove_liquidity_one_coin is used\n    // For plain Curve pools\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n\n    // For Curve pools where Zap contract is used i.e. Meta pools\n    function calc_withdraw_one_coin(address _pool, uint256 _token_amount, int128 i) external view returns (uint256);\n\n    // Remove liquidity one coin\n    // For plain Curve pools\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 _min_amount) external returns (uint256);\n\n    // For LendingToken Curve pools where use_underlying flag exists\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 _min_amount,\n        bool _use_underlying\n    ) external returns (uint256);\n\n    // For Curve pools where Zap contract is used i.e. Meta pools\n    function remove_liquidity_one_coin(\n        address _pool,\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_amount\n    ) external returns (uint256);\n\n    // Remove liquidity in all tokens\n    // For plain Curve pools\n    function remove_liquidity(uint256 _amount, uint256[2] memory _min_amounts) external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory _min_amounts) external;\n\n    function remove_liquidity(uint256 _amount, uint256[4] memory _min_amounts) external;\n\n    // For LendingToken Curve pools where use_underlying flag exists\n    function remove_liquidity(uint256 amount, uint256[2] calldata min_amounts, bool use_underlying) external;\n\n    function remove_liquidity(uint256 amount, uint256[3] calldata min_amounts, bool use_underlying) external;\n\n    function remove_liquidity(uint256 amount, uint256[4] calldata min_amounts, bool use_underlying) external;\n\n    // For Curve pools where Zap contract is used i.e. Meta pools\n    function remove_liquidity(address _pool, uint256 _burn_amount, uint256[2] memory _min_amounts) external;\n\n    function remove_liquidity(address _pool, uint256 _burn_amount, uint256[3] memory _min_amounts) external;\n\n    function remove_liquidity(address _pool, uint256 _burn_amount, uint256[4] memory _min_amounts) external;\n\n    // For Curve pools with dynamic array\n    function remove_liquidity(uint256 _amount, uint256[] memory _min_amounts) external;\n\n    function remove_liquidity(address _pool, uint256 _burn_amount, uint256[] memory _min_amounts) external;\n}\n"
    },
    "contracts/interfaces/curve/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ILiquidityGauge {\n    function lp_token() external view returns (address);\n\n    function deposit(uint256 _value) external;\n\n    function withdraw(uint256 _value) external;\n}\n\ninterface ILiquidityGaugeReward {\n    function rewarded_token() external view returns (address);\n}\n\ninterface ILiquidityGaugeV2 is IERC20, ILiquidityGauge {\n    function claim_rewards() external;\n\n    function reward_count() external view returns (uint256);\n\n    function reward_tokens(uint256 _i) external view returns (address);\n\n    function set_approve_deposit(address addr, bool can_deposit) external;\n}\n\n/* solhint-enable */\n"
    },
    "contracts/interfaces/curve/ILiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.8.25;\n\ninterface ILiquidityGaugeFactory {\n    function get_gauge_from_lp_token(address lp_token) external view returns (address);\n\n    function is_valid_gauge(address _gauge) external view returns (bool);\n\n    function mint(address gauge_addr) external;\n}\n/* solhint-enable */\n"
    },
    "contracts/interfaces/curve/IMetaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.8.25;\n\ninterface IMetaRegistry {\n    function get_gauge(address pool) external view returns (address);\n\n    function get_lp_token(address pool) external view returns (address);\n\n    function get_n_coins(address pool) external view returns (uint256);\n\n    function get_n_underlying_coins(address pool) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_balances(address pool) external view returns (uint256[8] memory);\n\n    function get_pool_from_lp_token(address token) external view returns (address);\n\n    function get_underlying_coins(address pool) external view returns (address[8] memory);\n\n    function get_underlying_balances(address pool) external view returns (uint256[8] memory);\n\n    function is_meta(address pool) external view returns (bool);\n\n    function is_registered(address pool) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/curve/ITokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface ITokenMinter {\n    function mint(address gaugeAddr) external;\n}\n"
    },
    "contracts/interfaces/euler/IEulerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IEulerV2 is IERC20 {\n    function asset() external view returns (address);\n\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/extra-finance/IEToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IEToken is IERC20 {\n    function lendingPool() external view returns (address);\n}\n"
    },
    "contracts/interfaces/extra-finance/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface ILendingPool {\n    // Interest Rate Config\n    // The utilization rate and borrowing rate are expressed in RAY\n    // utilizationB must gt utilizationA\n    struct InterestRateConfig {\n        // The utilization rate a, the end of the first slope on interest rate curve\n        uint128 utilizationA;\n        // The borrowing rate at utilization_rate_a\n        uint128 borrowingRateA;\n        // The utilization rate a, the end of the first slope on interest rate curve\n        uint128 utilizationB;\n        // The borrowing rate at utilization_rate_b\n        uint128 borrowingRateB;\n        // the max borrowing rate while the utilization is 100%\n        uint128 maxBorrowingRate;\n    }\n\n    struct ReserveData {\n        // variable borrow index.\n        uint256 borrowingIndex;\n        // the current borrow rate.\n        uint256 currentBorrowingRate;\n        // the total borrows of the reserve at a variable rate. Expressed in the currency decimals\n        uint256 totalBorrows;\n        // underlying token address\n        address underlyingTokenAddress;\n        // eToken address\n        address eTokenAddress;\n        // staking address\n        address stakingAddress;\n        // the capacity of the reserve pool\n        uint256 reserveCapacity;\n        // borrowing rate config\n        InterestRateConfig borrowingRateConfig;\n        // the id of the reserve. Represents the position in the list of the reserves\n        uint256 id;\n        uint128 lastUpdateTimestamp;\n        // reserve fee charged, percent of the borrowing interest that is put into the treasury.\n        uint16 reserveFeeRate;\n        Flags flags;\n    }\n\n    struct Flags {\n        bool isActive; // set to 1 if the reserve is properly configured\n        bool frozen; // set to 1 if reserve is frozen, only allows repays and withdraws, but not deposits or new borrowings\n        bool borrowingEnabled; // set to 1 if borrowing is enabled, allow borrowing from this pool\n    }\n\n    function reserves(uint256) external view returns (ReserveData memory);\n\n    function utilizationRateOfReserve(uint256 reserveId) external view returns (uint256);\n\n    function borrowingRateOfReserve(uint256 reserveId) external view returns (uint256);\n\n    function exchangeRateOfReserve(uint256 reserveId) external view returns (uint256);\n\n    function totalLiquidityOfReserve(uint256 reserveId) external view returns (uint256 totalLiquidity);\n\n    function totalBorrowsOfReserve(uint256 reserveId) external view returns (uint256 totalBorrows);\n\n    function getReserveIdOfDebt(uint256 debtId) external view returns (uint256);\n\n    struct ReserveStatus {\n        uint256 reserveId;\n        address underlyingTokenAddress;\n        address eTokenAddress;\n        address stakingAddress;\n        uint256 totalLiquidity;\n        uint256 totalBorrows;\n        uint256 exchangeRate;\n        uint256 borrowingRate;\n    }\n\n    struct PositionStatus {\n        uint256 reserveId;\n        address user;\n        uint256 eTokenStaked;\n        uint256 eTokenUnStaked;\n        uint256 liquidity;\n    }\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying eTokens.\n     * - E.g. User deposits 100 USDC and gets in return for specific amount of eUSDC\n     * the eUSDC amount depends on the exchange rate between USDC and eUSDC\n     * @param reserveId The ID of the reserve\n     * @param amount The amount of reserve to be deposited\n     * @param onBehalfOf The address that will receive the eTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of eTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        uint256 reserveId,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external payable returns (uint256 eTokenAmount);\n\n    function depositAndStake(\n        uint256 reserveId,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external payable returns (uint256 eTokenAmount);\n\n    function redeem(\n        uint256 reserveId,\n        uint256 eTokenAmount,\n        address to,\n        bool receiveNativeETH\n    ) external payable returns (uint256 underlyingTokenAmount);\n\n    function unStakeAndWithdraw(\n        uint256 reserveId,\n        uint256 eTokenAmount,\n        address to,\n        bool receiveNativeETH\n    ) external payable returns (uint256 underlyingTokenAmount);\n\n    function newDebtPosition(uint256 reserveId) external returns (uint256);\n\n    function getCurrentDebt(uint256 debtId) external view returns (uint256 currentDebt, uint256 latestBorrowingIndex);\n\n    /**\n     * @dev Allows farming users to borrow a specific `amount` of the reserve underlying asset.\n     * The user's borrowed tokens is transferred to the vault position contract and is recorded in the user's vault position(VaultPositionManageContract).\n     * When debt ratio of user's vault position reach the liquidate limit,\n     * the position will be liquidated and repay his debt(borrowed value + accrued interest)\n     * @param onBehalfOf The beneficiary of the borrowing, receiving the tokens in his vaultPosition\n     * @param debtId The debtPositionId\n     * @param amount The amount to be borrowed\n     */\n    function borrow(address onBehalfOf, uint256 debtId, uint256 amount) external;\n\n    /**\n     * @notice Repays borrowed underlying tokens to the reserve pool\n     * The user's debt is recorded in the vault position(VaultPositionManageContract).\n     * After this function successfully executed, user's debt should be reduced in VaultPositionManageContract.\n     * @param onBehalfOf The user who repay debts in his vaultPosition\n     * @param debtId The debtPositionId\n     * @param amount The amount to be borrowed\n     * @return The final amount repaid\n     **/\n    function repay(address onBehalfOf, uint256 debtId, uint256 amount) external returns (uint256);\n\n    function getUnderlyingTokenAddress(uint256 reserveId) external view returns (address underlyingTokenAddress);\n\n    function getETokenAddress(uint256 reserveId) external view returns (address eTokenAddress);\n\n    function getStakingAddress(uint256 reserveId) external view returns (address);\n}\n"
    },
    "contracts/interfaces/extra-finance/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStakingRewards {\n    event RewardsSet(address rewardsToken, uint256 start, uint256 end, uint256 total);\n\n    event Staked(address indexed user, address indexed onBehalfOf, uint256 amount);\n\n    event Withdraw(address indexed user, address indexed to, uint256 amount);\n\n    event RewardPaid(address indexed user, address indexed rewardsToken, uint256 claimed);\n\n    struct Reward {\n        uint256 startTime;\n        uint256 endTime;\n        uint256 rewardRate;\n        uint256 lastUpdateTime;\n        uint256 rewardPerTokenStored;\n    }\n\n    function rewardTokens(uint256) external view returns (address);\n\n    function rewardPerToken(address rewardsToken) external view returns (uint256);\n\n    function rewardData(address) external view returns (uint256, uint256, uint256, uint256, uint256);\n\n    function stakedToken() external view returns (IERC20);\n\n    function lendingPool() external view returns (address);\n\n    function totalStaked() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function rewardsTokenListLength() external view returns (uint256);\n\n    function earned(address _account, address _rewardsToken) external view returns (uint256);\n\n    function stake(uint _amount, address onBehalfOf) external;\n\n    function withdraw(uint _amount, address to) external;\n\n    function withdrawByLendingPool(uint _amount, address user, address to) external;\n\n    function claim() external;\n\n    function userRewardsClaimable(address _account, address _rewardsToken) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/fraxlend/IFraxlendPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IFraxlendPairBase} from \"./IFraxlendPairBase.sol\";\n\n// solhint-disable var-name-mixedcase\ninterface IFraxlendPair is IFraxlendPairBase {\n    struct ExchangeRateInfo {\n        uint32 lastTimestamp;\n        uint224 exchangeRate; // collateral:asset ratio. i.e. how much collateral to buy 1e18 asset\n    }\n\n    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio\n    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token\n    function exchangeRateInfo() external view returns (ExchangeRateInfo memory);\n\n    function getConstants()\n        external\n        pure\n        returns (\n            uint256 _LTV_PRECISION,\n            uint256 _LIQ_PRECISION,\n            uint256 _UTIL_PREC,\n            uint256 _FEE_PRECISION,\n            uint256 _EXCHANGE_PRECISION,\n            uint64 _DEFAULT_INT,\n            uint16 _DEFAULT_PROTOCOL_FEE,\n            uint256 _MAX_PROTOCOL_FEE\n        );\n\n    function oracleMultiply() external view returns (address);\n\n    function oracleDivide() external view returns (address);\n\n    /// @notice The ```toAssetAmount``` function converts a given number of shares to an asset amount\n    /// @param _shares Shares of asset (fToken)\n    /// @param _roundUp Whether to round up after division\n    /// @return The amount of asset\n    function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256);\n\n    /// @notice The ```toAssetShares``` function converts a given asset amount to a number of asset shares (fTokens)\n    /// @param _amount The amount of asset\n    /// @param _roundUp Whether to round up after division\n    /// @return The number of shares (fTokens)\n    function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256);\n\n    /// @notice The ```addInterest``` function is a public implementation of _addInterest and allows 3rd parties to trigger interest accrual\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function addInterest()\n        external\n        returns (uint256 _interestEarned, uint256 _feesAmount, uint256 _feesShare, uint64 _newRate);\n\n    /// @notice The ```redeem``` function allows the caller to redeem their Asset Shares for Asset Tokens\n    /// @param _shares The number of Asset Shares (fTokens) to burn for Asset Tokens\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _amountToReturn The amount of Asset Tokens to be transferred\n    function redeem(uint256 _shares, address _receiver, address _owner) external returns (uint256 _amountToReturn);\n}\n"
    },
    "contracts/interfaces/fraxlend/IFraxlendPairBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// solhint-disable var-name-mixedcase\n\ninterface IFraxlendPairBase is IERC20 {\n    function asset() external view returns (address);\n\n    function collateralContract() external view returns (address);\n\n    function maxLTV() external view returns (uint256);\n\n    /// @notice The ```toBorrowAmount``` function converts a given amount of borrow debt into the number of shares\n    /// @param _shares Shares of borrow\n    /// @param _roundUp Whether to roundup during division\n    /// @return The amount of asset\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256);\n\n    /// @notice The ```toBorrowShares``` function converts a given amount of borrow debt into the number of shares\n    /// @param _amount Amount of borrow\n    /// @param _roundUp Whether to roundup during division\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256);\n\n    struct VaultAccount {\n        uint128 amount; // Total amount, analogous to market cap\n        uint128 shares; // Total shares, analogous to shares outstanding\n    }\n\n    function totalAsset() external view returns (VaultAccount memory);\n\n    function totalBorrow() external view returns (VaultAccount memory);\n\n    // total amount of collateral in contract\n    function totalCollateral() external view returns (uint256);\n\n    /// @notice Stores the balance of collateral for each user\n    function userCollateralBalance(address _user) external view returns (uint256);\n\n    /// @notice Stores the balance of borrow shares for each user\n    function userBorrowShares(address _user) external view returns (uint256);\n\n    /// @notice The ```deposit``` function allows a user to Lend Assets by specifying the amount of Asset Tokens to lend\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _amount The amount of Asset Token to transfer to Pair\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _sharesReceived The number of fTokens received for the deposit\n    function deposit(uint256 _amount, address _receiver) external returns (uint256 _sharesReceived);\n\n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(uint256 _collateralAmount, address _borrower) external;\n\n    /// @notice The ```removeCollateral``` function is used to remove collateral from msg.sender's borrow position\n    /// @dev msg.sender must be solvent after invocation or transaction will revert\n    /// @param _collateralAmount The amount of Collateral Token to transfer\n    /// @param _receiver The address to receive the transferred funds\n    function removeCollateral(uint256 _collateralAmount, address _receiver) external;\n\n    /// @notice The ```borrowAsset``` function allows a user to open/increase a borrow position\n    /// @dev Borrower must call ```ERC20.approve``` on the Collateral Token contract if applicable\n    /// @param _borrowAmount The amount of Asset Token to borrow\n    /// @param _collateralAmount The amount of Collateral Token to transfer to Pair\n    /// @param _receiver The address which will receive the Asset Tokens\n    /// @return _shares The number of borrow Shares the msg.sender will be debited\n    function borrowAsset(\n        uint256 _borrowAmount,\n        uint256 _collateralAmount,\n        address _receiver\n    ) external returns (uint256 _shares);\n\n    /// @notice The ```repayAsset``` function allows the caller to pay down the debt for a given borrower.\n    /// @dev Caller must first invoke ```ERC20.approve()``` for the Asset Token contract\n    /// @param _shares The number of Borrow Shares which will be repaid by the call\n    /// @param _borrower The account for which the debt will be reduced\n    /// @return _amountToRepay The amount of Asset Tokens which were transferred in order to repay the Borrow Shares\n    function repayAsset(uint256 _shares, address _borrower) external returns (uint256 _amountToRepay);\n}\n"
    },
    "contracts/interfaces/fraxlend/IFraxlendPairV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IFraxlendPairBase} from \"./IFraxlendPairBase.sol\";\n\n// solhint-disable var-name-mixedcase\ninterface IFraxlendPairV3 is IFraxlendPairBase {\n    struct ExchangeRateInfo {\n        address oracle;\n        uint32 maxOracleDeviation; // % of larger number, 1e5 precision\n        uint184 lastTimestamp;\n        uint256 lowExchangeRate;\n        uint256 highExchangeRate;\n    }\n\n    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio\n    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token\n    function exchangeRateInfo() external view returns (ExchangeRateInfo memory);\n\n    function getConstants()\n        external\n        pure\n        returns (\n            uint256 _LTV_PRECISION,\n            uint256 _LIQ_PRECISION,\n            uint256 _UTIL_PREC,\n            uint256 _FEE_PRECISION,\n            uint256 _EXCHANGE_PRECISION,\n            uint256 _DEVIATION_PRECISION,\n            uint256 _RATE_PRECISION,\n            uint256 _MAX_PROTOCOL_FEE\n        );\n\n    /// @notice The ```toAssetAmount``` function converts a given number of shares to an asset amount\n    /// @param _shares Shares of asset (fToken)\n    /// @param _roundUp Whether to round up after division\n    /// @param _previewInterest Whether to preview interest accrual before calculation\n    /// @return _amount The amount of asset\n    function toAssetAmount(uint256 _shares, bool _roundUp, bool _previewInterest) external view returns (uint256);\n\n    /// @notice The ```toAssetShares``` function converts a given asset amount to a number of asset shares (fTokens)\n    /// @param _amount The amount of asset\n    /// @param _roundUp Whether to round up after division\n    /// @param _previewInterest Whether to preview interest accrual before calculation\n    /// @return _shares The number of shares (fTokens)\n    function toAssetShares(uint256 _amount, bool _roundUp, bool _previewInterest) external view returns (uint256);\n\n    function convertToAssets(uint256 _shares) external view returns (uint256 _assets);\n\n    function convertToShares(uint256 _assets) external view returns (uint256 _shares);\n\n    function pricePerShare() external view returns (uint256 _amount);\n\n    function totalAssets() external view returns (uint256);\n\n    function maxWithdraw(address _owner) external view returns (uint256 _maxAssets);\n\n    /// @notice The ```withdraw``` function allows the caller to withdraw their Asset Tokens for a given amount of fTokens\n    /// @param _amount The amount to withdraw\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _sharesToBurn The number of shares (fTokens) that were burned\n    function withdraw(uint256 _amount, address _receiver, address _owner) external returns (uint256 _sharesToBurn);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/lido/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWstETH is IERC20 {\n    function unwrap(uint256 _wstETHAmount) external returns (uint256 _stETHAmount);\n\n    function wrap(uint256 _stETHAmount) external returns (uint256 _wstETHAmount);\n\n    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256 _stETHAmount);\n\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256 _wstETHAmount);\n}\n"
    },
    "contracts/interfaces/morpho/IMetaMorpho.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMetaMorpho is IERC20 {\n    function asset() external view returns (address);\n\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/one-oracle/IMasterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IMasterOracle {\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n\n    function quote(address tokenIn_, address tokenOut_, uint256 amountIn_) external view returns (uint256 _amountOut);\n\n    function quoteTokenToUsd(address token_, uint256 amountIn_) external view returns (uint256 amountOut_);\n\n    function quoteUsdToToken(address token_, uint256 amountIn_) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/interfaces/sommelier/ISommelier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICellar is IERC20 {\n    function asset() external view returns (address);\n\n    /**\n     * @notice The amount of assets that the cellar would exchange for the amount of shares provided.\n     * @param shares amount of shares to convert\n     * @return assets the shares can be exchanged for\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    /**\n     * @notice After deposits users must wait `shareLockPeriod` time before being able to transfer or withdraw their shares.\n     */\n    function shareLockPeriod() external view returns (uint256);\n\n    /**\n     * @notice The total amount of withdrawable assets in the cellar.\n     * @dev Run a re-entrancy check because totalAssetsWithdrawable can be wrong if re-entering from deposit/withdraws.\n     */\n    function totalAssetsWithdrawable() external view returns (uint256 assets);\n\n    /**\n     * @notice mapping that stores every users last time stamp they minted shares.\n     */\n    function userShareLockStartTime(address user) external view returns (uint256 lockTime);\n\n    /**\n     * @notice Simulate the effects of depositing assets at the current block, given current on-chain conditions.\n     * @param assets amount of assets to deposit\n     * @return shares that will be minted\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @notice Deposits assets into the cellar, and returns shares to receiver.\n     * @param assets amount of assets deposited by user.\n     * @param receiver address to receive the shares.\n     * @return shares amount of shares given for deposit.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Withdraw assets from the cellar by redeeming shares.\n     * @dev Unlike conventional ERC4626 contracts, this may not always return one asset to the receiver.\n     *      Since there are no swaps involved in this function, the receiver may receive multiple\n     *      assets. The value of all the assets returned will be equal to the amount defined by\n     *      `assets` denominated in the `asset` of the cellar (eg. if `asset` is USDC and `assets`\n     *      is 1000, then the receiver will receive $1000 worth of assets in either one or many\n     *      tokens).\n     * @param assets equivalent value of the assets withdrawn, denominated in the cellar's asset\n     * @param receiver address that will receive withdrawn assets\n     * @param owner address that owns the shares being redeemed\n     * @return shares amount of shares redeemed\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/stargate/v2/IMultiRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice A rewarder that can distribute multiple reward tokens (ERC20 and native) to `StargateStaking` pools.\ninterface IMultiRewarder {\n    struct RewardDetails {\n        uint256 rewardPerSec;\n        uint160 totalAllocPoints;\n        uint48 start;\n        uint48 end;\n        bool exists;\n    }\n\n    /**\n     *  @notice Returns the reward pools linked to the `stakingToken` alongside the pending rewards for `user`\n     *          for these pools.\n     */\n    function getRewards(IERC20 stakingToken, address user) external view returns (address[] memory, uint256[] memory);\n\n    /// @notice Returns all enabled reward tokens. Stopped reward tokens are not included, while ended rewards are.\n    function rewardTokens() external view returns (address[] memory);\n\n    /// @notice Returns the emission details of a `rewardToken`, configured via `setReward`.\n    function rewardDetails(address rewardToken) external view returns (RewardDetails memory);\n}\n"
    },
    "contracts/interfaces/stargate/v2/IStargatePoolV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IOFT {\n    /**\n     * @notice Retrieves the shared decimals of the OFT.\n     * @return sharedDecimals The shared decimals of the OFT.\n     */\n    function sharedDecimals() external view returns (uint8);\n}\n\ninterface IStargatePoolV2 is IOFT {\n    /// @notice Deposit token into the pool\n    /// @param _receiver The account to mint the LP tokens to\n    /// @param _amountLD The amount of tokens to deposit in LD\n    /// @return amountLD The actual amount of tokens deposited in LD\n    function deposit(address _receiver, uint256 _amountLD) external payable returns (uint256 amountLD);\n\n    /// @notice Redeem an amount of LP tokens from the senders account, claiming rewards.\n    /// @param _amountLD The amount of LP tokens to redeem\n    /// @param _receiver The account to transfer the\n    function redeem(uint256 _amountLD, address _receiver) external returns (uint256 amountLD);\n\n    /// @notice Get how many LP tokens are redeemable for a given account\n    /// @param _owner The address of the account to check\n    /// @return amountLD The amount of LP tokens redeemable, in LD\n    function redeemable(address _owner) external view returns (uint256 amountLD);\n\n    /// @notice Get the Total Value Locked in the pool.\n    /// @return The total value locked\n    function tvl() external view returns (uint256);\n\n    /// @notice Get the available balance of the pool\n    function poolBalance() external view returns (uint256);\n\n    /// @notice Get the address of the LP token\n    /// @return The address of the LP token contract.\n    function lpToken() external view returns (address);\n}\n"
    },
    "contracts/interfaces/stargate/v2/IStargateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IMultiRewarder} from \"./IMultiRewarder.sol\";\n\ninterface IStargateStaking {\n    /**\n     * @notice Deposits `amount` of `token` into the pool. Informs the rewarder of the deposit, triggering a harvest.\n     */\n    function deposit(IERC20 token, uint256 amount) external;\n\n    /// @notice Withdraws `amount` of `token` from the pool. Informs the rewarder of the withdrawal, triggers a harvest.\n    function withdraw(IERC20 token, uint256 amount) external;\n\n    /// @notice Withdraws `amount` of `token` from the pool in an always-working fashion. The rewarder is not informed.\n    function emergencyWithdraw(IERC20 token) external;\n\n    /// @notice Claims the rewards from the rewarder, and sends them to the caller.\n    function claim(IERC20[] calldata lpTokens) external;\n\n    /// @notice Returns the deposited balance of `user` in the pool of `token`.\n    function balanceOf(IERC20 token, address user) external view returns (uint256);\n\n    // @notice Returns the rewarder of the pool of `token`, responsible for distribution reward tokens.\n    function rewarder(IERC20 token) external view returns (IMultiRewarder);\n}\n"
    },
    "contracts/interfaces/swapper/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\n/**\n * @notice Swapper interface\n * @dev This contract doesn't support native coins (e.g. ETH, AVAX, MATIC, etc) use wrapper tokens instead\n */\ninterface ISwapper {\n    /**\n     * @notice The list of supported DEXes\n     * @dev This function is gas intensive\n     */\n    function getAllExchanges() external view returns (address[] memory);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountIn(address tokenIn_, address tokenOut_, uint256 amountOut_) external returns (uint256 _amountIn);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountOut(address tokenIn_, address tokenOut_, uint256 amountIn_) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact input swap - will revert if there is no default routing\n     */\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address _receiver\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact output swap - will revert if there is no default routing\n     */\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address receiver_\n    ) external returns (uint256 _amountIn);\n}\n"
    },
    "contracts/interfaces/vesper/IPoolAccountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IPoolAccountant {\n    function addStrategy(address strategy_, uint256 debtRatio_, uint256 externalDepositFee_) external;\n\n    function getStrategies() external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/vesper/IPoolRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IPoolRewards {\n    /// Emitted after reward added\n    event RewardAdded(address indexed rewardToken, uint256 reward, uint256 rewardDuration);\n    /// Emitted whenever any user claim rewards\n    event RewardPaid(address indexed user, address indexed rewardToken, uint256 reward);\n    /// Emitted after adding new rewards token into rewardTokens array\n    event RewardTokenAdded(address indexed rewardToken, address[] existingRewardTokens);\n\n    function claimReward(address) external;\n\n    function notifyRewardAmount(address rewardToken_, uint256 _rewardAmount, uint256 _rewardDuration) external;\n\n    function notifyRewardAmount(\n        address[] memory rewardTokens_,\n        uint256[] memory rewardAmounts_,\n        uint256[] memory rewardDurations_\n    ) external;\n\n    function updateReward(address) external;\n\n    function claimable(\n        address account_\n    ) external view returns (address[] memory _rewardTokens, uint256[] memory _claimableAmounts);\n\n    function lastTimeRewardApplicable(address rewardToken_) external view returns (uint256);\n\n    function rewardForDuration()\n        external\n        view\n        returns (address[] memory _rewardTokens, uint256[] memory _rewardForDuration);\n\n    function rewardPerToken()\n        external\n        view\n        returns (address[] memory _rewardTokens, uint256[] memory _rewardPerTokenRate);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isRewardToken(address) external view returns (bool);\n\n    function addRewardToken(address newRewardToken_) external;\n\n    function periodFinish(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/vesper/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStrategy {\n    function rebalance() external returns (uint256 _profit, uint256 _loss, uint256 _payback);\n\n    function sweep(address _fromToken) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function collateralToken() external view returns (IERC20);\n\n    function feeCollector() external view returns (address);\n\n    function isActive() external view returns (bool);\n\n    function isReservedToken(address _token) external view returns (bool);\n\n    function keepers() external view returns (address[] memory);\n\n    function receiptToken() external view returns (address);\n\n    function pool() external view returns (address);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function VERSION() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/vesper/IVesperPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IVesperPool is IERC20Metadata {\n    function calculateUniversalFee(uint256 profit_) external view returns (uint256 _fee);\n\n    function deposit(uint256 collateralAmount_) external;\n\n    function excessDebt(address strategy_) external view returns (uint256);\n\n    function poolAccountant() external view returns (address);\n\n    function poolRewards() external view returns (address);\n\n    function reportEarning(uint256 profit_, uint256 loss_, uint256 payback_) external;\n\n    function reportLoss(uint256 loss_) external;\n\n    function sweepERC20(address fromToken_) external;\n\n    function withdraw(uint256 share_) external;\n\n    function keepers() external view returns (address[] memory);\n\n    function isKeeper(address address_) external view returns (bool);\n\n    function maintainers() external view returns (address[] memory);\n\n    function isMaintainer(address address_) external view returns (bool);\n\n    function pricePerShare() external view returns (uint256);\n\n    function strategy(\n        address strategy_\n    )\n        external\n        view\n        returns (\n            bool _active,\n            uint256 _interestFee, // Obsolete\n            uint256 _debtRate, // Obsolete\n            uint256 _lastRebalance,\n            uint256 _totalDebt,\n            uint256 _totalLoss,\n            uint256 _totalProfit,\n            uint256 _debtRatio,\n            uint256 _externalDepositFee\n        );\n\n    function token() external view returns (IERC20);\n\n    function tokensHere() external view returns (uint256);\n\n    function totalDebtOf(address strategy_) external view returns (uint256);\n\n    function totalValue() external view returns (uint256);\n\n    function totalDebt() external view returns (uint256);\n\n    function governor() external view returns (address);\n}\n"
    },
    "contracts/interfaces/yearn/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IStakingRewards {\n    /// @notice The balance a given user has staked.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Amount of reward token pending claim by an account.\n    function earned(address account) external view returns (uint256);\n\n    /// @notice The address of our rewards token.\n    function rewardsToken() external view returns (address);\n\n    /// @notice The total tokens staked in this contract.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Unstake all of the sender's tokens and claim any outstanding rewards.\n    function exit() external;\n\n    /// @notice Claim any earned reward tokens.\n    /// @dev Can claim rewards even if no tokens still staked.\n    function getReward() external;\n\n    /// @notice Deposit vault tokens to the staking pool.\n    /// @dev Can't stake zero.\n    /// @param amount Amount of vault tokens to deposit.\n    function stake(uint256 amount) external;\n\n    /// @notice Withdraw vault tokens from the staking pool.\n    /// @dev Can't withdraw zero. If trying to claim, call getReward() instead.\n    /// @param amount Amount of vault tokens to withdraw.\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/yearn/IYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IYToken {\n    function balanceOf(address user) external view returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function deposit(uint256 amount) external returns (uint256);\n\n    function deposit() external returns (uint256);\n\n    function withdraw(uint256 shares) external returns (uint256);\n\n    function token() external returns (address);\n\n    function totalAssets() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function availableDepositLimit() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function withdrawalQueue(uint256 index) external view returns (address);\n\n    function maxAvailableShares() external view returns (uint256);\n}\n"
    },
    "contracts/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n"
    },
    "contracts/strategies/aave/v3/AaveV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IAToken} from \"../../../interfaces/aave/IAToken.sol\";\nimport {IIncentivesController} from \"../../../interfaces/aave/IIncentivesController.sol\";\nimport {ILendingPool} from \"../../../interfaces/aave/ILendingPool.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/aave/IPoolAddressesProvider.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {Strategy} from \"../../Strategy.sol\";\nimport {AaveV3Incentive} from \"./AaveV3Incentive.sol\";\n\n/// @dev This strategy will deposit collateral token in Aave and earn interest.\ncontract AaveV3 is Strategy {\n    using SafeERC20 for IERC20;\n\n    error IncorrectWithdrawAmount();\n    error InvalidReceiptToken();\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.AaveV3\n    struct AaveV3Storage {\n        IPoolAddressesProvider _poolAddressesProvider;\n    }\n\n    bytes32 private constant AaveV3StorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.AaveV3\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getAaveV3Storage() internal pure returns (AaveV3Storage storage $) {\n        bytes32 _location = AaveV3StorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        address poolAddressesProvider_,\n        string memory name_\n    ) external initializer {\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n\n        if (poolAddressesProvider_ == address(0)) revert AddressIsNull();\n        if (IAToken(receiptToken_).UNDERLYING_ASSET_ADDRESS() != address(IVesperPool(pool_).token()))\n            revert InvalidReceiptToken();\n        _getAaveV3Storage()._poolAddressesProvider = IPoolAddressesProvider(poolAddressesProvider_);\n    }\n\n    function aavePoolAddressesProvider() public view returns (IPoolAddressesProvider) {\n        return _getAaveV3Storage()._poolAddressesProvider;\n    }\n\n    /**\n     * @notice Report total value locked in this strategy\n     * @dev aToken and collateral are 1:1\n     */\n    function tvl() public view override returns (uint256 _tvl) {\n        // receiptToken is aToken\n        _tvl = IERC20(receiptToken()).balanceOf(address(this)) + collateralToken().balanceOf(address(this));\n    }\n\n    /// @notice Large approval of token\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(aavePoolAddressesProvider().getPool()), amount_);\n    }\n\n    /// @dev Override function defined in Strategy.sol to claim all rewards from protocol.\n    function _claimRewards() internal override {\n        AaveV3Incentive._claimRewards(receiptToken());\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n\n        uint256 _totalCollateral = IERC20((receiptToken())).balanceOf(address(this)) + _collateralHere;\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        _pool.reportEarning(_profit, _loss, _payback);\n\n        // strategy may get new fund. deposit to generate yield\n        _collateralHere = _collateralToken.balanceOf(address(this));\n        if (_collateralHere > 0) {\n            aavePoolAddressesProvider().getPool().supply(address(_collateralToken), _collateralHere, address(this), 0);\n        }\n    }\n\n    /// @dev Withdraw collateral here. Do not transfer to pool\n    function _withdrawHere(uint256 requireAmount_) internal override {\n        IERC20 _collateralToken = collateralToken();\n        address _receiptToken = receiptToken();\n        // withdraw asking more than available liquidity will fail. To do safe withdraw, check\n        // requireAmount_ against available liquidity.\n        uint256 _possibleWithdraw = Math.min(\n            requireAmount_,\n            Math.min(IERC20(_receiptToken).balanceOf(address(this)), _collateralToken.balanceOf(_receiptToken))\n        );\n        if (_possibleWithdraw > 0) {\n            if (\n                aavePoolAddressesProvider().getPool().withdraw(\n                    address(_collateralToken),\n                    _possibleWithdraw,\n                    address(this)\n                ) != _possibleWithdraw\n            ) revert IncorrectWithdrawAmount();\n        }\n    }\n}\n"
    },
    "contracts/strategies/aave/v3/AaveV3Borrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IAToken} from \"../../../interfaces/aave/IAToken.sol\";\nimport {IIncentivesController} from \"../../../interfaces/aave/IIncentivesController.sol\";\nimport {ILendingPool} from \"../../../interfaces/aave/ILendingPool.sol\";\nimport {IAaveOracle} from \"../../../interfaces/aave/IAaveOracle.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/aave/IPoolAddressesProvider.sol\";\nimport {IProtocolDataProvider} from \"../../../interfaces/aave/IProtocolDataProvider.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {Strategy} from \"../../Strategy.sol\";\nimport {AaveV3Incentive} from \"./AaveV3Incentive.sol\";\n\n/// @title Deposit Collateral in Aave and earn interest by depositing borrowed token in a Vesper Pool.\nabstract contract AaveV3Borrow is Strategy {\n    using SafeERC20 for IERC20;\n\n    error DepositFailed(string reason);\n    error IncorrectWithdrawAmount();\n    error InvalidInput();\n    error InvalidMaxBorrowLimit();\n    error InvalidReceiptToken();\n    error InvalidSlippage();\n    error MaxShouldBeHigherThanMin();\n    error PriceError();\n\n    uint256 internal constant MAX_BPS = 10_000; //100%\n\n    event UpdatedBorrowLimit(\n        uint256 previousMinBorrowLimit,\n        uint256 newMinBorrowLimit,\n        uint256 previousMaxBorrowLimit,\n        uint256 newMaxBorrowLimit\n    );\n\n    event UpdatedSlippage(uint256 previousSlippage, uint256 newSlippage);\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.AaveV3Borrow\n    struct AaveV3BorrowStorage {\n        IPoolAddressesProvider _poolAddressesProvider;\n        address _borrowToken;\n        IAToken _vdToken; // variable debt token\n        address _aBorrowToken;\n        IERC20 _wrappedCollateral;\n        uint256 _minBorrowLimit;\n        uint256 _maxBorrowLimit;\n        uint256 _slippage;\n    }\n\n    bytes32 private constant AaveV3BorrowStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.AaveV3Borrow\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getAaveV3BorrowStorage() internal pure returns (AaveV3BorrowStorage storage $) {\n        bytes32 _location = AaveV3BorrowStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function __AaveV3Borrow_init(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        address borrowToken_,\n        address poolAddressesProvider_,\n        string memory name_\n    ) internal initializer {\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n\n        if (borrowToken_ == address(0) || poolAddressesProvider_ == address(0)) revert AddressIsNull();\n\n        IERC20 _wrappedCollateral = _getWrappedToken(collateralToken());\n        if (IAToken(receiptToken_).UNDERLYING_ASSET_ADDRESS() != address(_wrappedCollateral))\n            revert InvalidReceiptToken();\n\n        (address _aBorrowToken, , address _vdToken) = IPoolAddressesProvider(poolAddressesProvider_)\n            .getPoolDataProvider()\n            .getReserveTokensAddresses(borrowToken_);\n\n        AaveV3BorrowStorage storage $ = _getAaveV3BorrowStorage();\n        $._poolAddressesProvider = IPoolAddressesProvider(poolAddressesProvider_);\n        $._borrowToken = borrowToken_;\n        $._vdToken = IAToken(_vdToken);\n        $._aBorrowToken = _aBorrowToken;\n        $._wrappedCollateral = _wrappedCollateral;\n\n        $._minBorrowLimit = 7_000; // 70% of actual collateral factor of protocol\n        $._maxBorrowLimit = 8_500; // 85% of actual collateral factor of protocol\n        $._slippage = 300; // 3%\n    }\n\n    function aavePoolAddressesProvider() public view returns (IPoolAddressesProvider) {\n        return _getAaveV3BorrowStorage()._poolAddressesProvider;\n    }\n\n    function aBorrowToken() public view returns (address) {\n        return _getAaveV3BorrowStorage()._aBorrowToken;\n    }\n\n    function borrowToken() public view returns (address) {\n        return _getAaveV3BorrowStorage()._borrowToken;\n    }\n\n    function isReservedToken(address token_) public view virtual override returns (bool) {\n        return super.isReservedToken(token_) || token_ == borrowToken();\n    }\n\n    function maxBorrowLimit() public view returns (uint256) {\n        return _getAaveV3BorrowStorage()._maxBorrowLimit;\n    }\n\n    function minBorrowLimit() public view returns (uint256) {\n        return _getAaveV3BorrowStorage()._minBorrowLimit;\n    }\n\n    function slippage() public view returns (uint256) {\n        return _getAaveV3BorrowStorage()._slippage;\n    }\n\n    /// @notice Returns total collateral locked in the strategy\n    function tvl() external view virtual override returns (uint256) {\n        // receiptToken is aToken. aToken is 1:1 of collateral token\n        return IERC20(receiptToken()).balanceOf(address(this)) + collateralToken().balanceOf(address(this));\n    }\n\n    function vdToken() public view returns (IAToken) {\n        return _getAaveV3BorrowStorage()._vdToken;\n    }\n\n    function wrappedCollateral() public view returns (IERC20) {\n        return _getAaveV3BorrowStorage()._wrappedCollateral;\n    }\n\n    /// @notice After borrowing Y Hook\n    function _afterBorrowY(uint256 amount_) internal virtual;\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal virtual override {\n        super._approveToken(amount_);\n        address _swapper = address(swapper());\n        IERC20 _wrappedCollateral = wrappedCollateral();\n        IERC20 _borrowToken = IERC20(borrowToken());\n        address _lendingPool = address(aavePoolAddressesProvider().getPool());\n        _wrappedCollateral.forceApprove(_lendingPool, amount_);\n        _wrappedCollateral.forceApprove(_swapper, amount_);\n        _borrowToken.forceApprove(_lendingPool, amount_);\n        _borrowToken.forceApprove(_swapper, amount_);\n    }\n\n    /// @notice Before repaying Y Hook\n    function _beforeRepayY(uint256 amount_) internal virtual;\n\n    /**\n     * @notice Calculate borrow and repay amount based on current collateral and new deposit/withdraw amount.\n     * @param depositAmount_ wrapped collateral amount to deposit\n     * @param withdrawAmount_ wrapped collateral amount to withdraw\n     * @param borrowed_ borrowed from protocol\n     * @param supplied_ wrapped collateral supplied to protocol\n     * @return _borrowAmount borrow more amount\n     * @return _repayAmount repay amount to keep ltv within limit\n     */\n    function _calculateBorrowPosition(\n        uint256 depositAmount_,\n        uint256 withdrawAmount_,\n        uint256 borrowed_,\n        uint256 supplied_\n    ) internal view returns (uint256 _borrowAmount, uint256 _repayAmount) {\n        if (depositAmount_ != 0 && withdrawAmount_ != 0) revert InvalidInput();\n        // If maximum borrow limit set to 0 then repay borrow\n        if (maxBorrowLimit() == 0) {\n            return (0, borrowed_);\n        }\n        // In case of withdraw, _amount can be greater than _supply\n        uint256 _hypotheticalCollateral = depositAmount_ > 0 ? supplied_ + depositAmount_ : supplied_ > withdrawAmount_\n            ? supplied_ - withdrawAmount_\n            : 0;\n        if (_hypotheticalCollateral == 0) {\n            return (0, borrowed_);\n        }\n        IAaveOracle _aaveOracle = aavePoolAddressesProvider().getPriceOracle();\n        address _borrowToken = borrowToken();\n        address _wrappedCollateral = address(wrappedCollateral());\n        uint256 _borrowTokenPrice = _aaveOracle.getAssetPrice(_borrowToken);\n        uint256 _collateralTokenPrice = _aaveOracle.getAssetPrice(_wrappedCollateral);\n        if (_borrowTokenPrice == 0 || _collateralTokenPrice == 0) {\n            // Oracle problem. Lets payback all\n            return (0, borrowed_);\n        }\n        // _collateralFactor in 4 decimal. 10_000 = 100%\n        (, uint256 _collateralFactor, , , , , , , , ) = aavePoolAddressesProvider()\n            .getPoolDataProvider()\n            .getReserveConfigurationData(_wrappedCollateral);\n\n        // Collateral in base currency based on oracle price and cf;\n        uint256 _actualCollateralForBorrow = (_hypotheticalCollateral * _collateralFactor * _collateralTokenPrice) /\n            (MAX_BPS * (10 ** IERC20Metadata(_wrappedCollateral).decimals()));\n        // Calculate max borrow possible in borrow token number\n        uint256 _maxBorrowPossible = (_actualCollateralForBorrow * (10 ** IERC20Metadata(_borrowToken).decimals())) /\n            _borrowTokenPrice;\n        if (_maxBorrowPossible == 0) {\n            return (0, borrowed_);\n        }\n        // Safe buffer to avoid liquidation due to price variations.\n        uint256 _borrowUpperBound = (_maxBorrowPossible * maxBorrowLimit()) / MAX_BPS;\n\n        // Borrow up to _borrowLowerBound and keep buffer of _borrowUpperBound - _borrowLowerBound for price variation\n        uint256 _borrowLowerBound = (_maxBorrowPossible * minBorrowLimit()) / MAX_BPS;\n\n        // If current borrow is greater than max borrow, then repay to achieve safe position.\n        if (borrowed_ > _borrowUpperBound) {\n            // If borrow > upperBound then it is greater than lowerBound too.\n            _repayAmount = borrowed_ - _borrowLowerBound;\n        } else if (_borrowLowerBound > borrowed_) {\n            _borrowAmount = _borrowLowerBound - borrowed_;\n            uint256 _availableLiquidity = IERC20(_borrowToken).balanceOf(aBorrowToken());\n            if (_borrowAmount > _availableLiquidity) {\n                _borrowAmount = _availableLiquidity;\n            }\n        }\n    }\n\n    function _calculateUnwrapped(uint256 wrappedAmount_) internal view virtual returns (uint256) {\n        return wrappedAmount_;\n    }\n\n    function _calculateWrapped(uint256 unwrappedAmount_) internal view virtual returns (uint256) {\n        return unwrappedAmount_;\n    }\n\n    /// @dev Override function defined in Strategy.sol to claim all rewards from protocol.\n    function _claimRewards() internal override {\n        AaveV3Incentive._claimRewards(receiptToken());\n    }\n\n    function _depositToAave(uint256 amount_, ILendingPool aaveLendingPool_) internal {\n        uint256 _wrappedAmount = _wrap(amount_);\n        if (_wrappedAmount > 0) {\n            // solhint-disable-next-line no-empty-blocks\n            try aaveLendingPool_.supply(address(wrappedCollateral()), _wrappedAmount, address(this), 0) {} catch Error(\n                string memory _reason\n            ) {\n                // Aave uses liquidityIndex and some other indexes as needed to normalize input.\n                // If normalized input equals to 0 then error will be thrown with '56' error code.\n                // CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\n                // Hence discard error where error code is '56'\n                if (bytes32(bytes(_reason)) != \"56\") revert DepositFailed(_reason);\n            }\n        }\n    }\n\n    function _getCollateralHere() internal virtual returns (uint256) {\n        return collateralToken().balanceOf(address(this));\n    }\n\n    /// @notice Borrowed Y balance deposited here or elsewhere hook\n    function _getInvestedBorrowBalance() internal view virtual returns (uint256) {\n        return IERC20(borrowToken()).balanceOf(address(this));\n    }\n\n    function _getWrappedToken(IERC20 unwrappedToken_) internal view virtual returns (IERC20) {\n        return unwrappedToken_;\n    }\n\n    /**\n     * @dev get quote for token price in terms of other token.\n     * @param tokenIn_ tokenIn\n     * @param tokenOut_ tokenOut\n     * @param amountIn_ amount of tokenIn_\n     * @return _amountOut amount of tokenOut_ for amountIn_ of tokenIn_\n     */\n    function _quote(address tokenIn_, address tokenOut_, uint256 amountIn_) internal view returns (uint256 _amountOut) {\n        IAaveOracle _aaveOracle = aavePoolAddressesProvider().getPriceOracle();\n        // Aave oracle prices are in WETH. Price is in 18 decimal.\n        uint256 _tokenInPrice = _aaveOracle.getAssetPrice(tokenIn_);\n        uint256 _tokenOutPrice = _aaveOracle.getAssetPrice(tokenOut_);\n        if (_tokenInPrice == 0 || _tokenOutPrice == 0) revert PriceError();\n        _amountOut =\n            (((_tokenInPrice * amountIn_) / 10 ** IERC20Metadata(tokenIn_).decimals()) *\n                (10 ** IERC20Metadata(tokenOut_).decimals())) /\n            _tokenOutPrice;\n    }\n\n    /**\n     * @dev Generate report for pools accounting and also send profit and any payback to pool.\n     */\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        // NOTE:: Pool has unwrapped as collateral and any state is also unwrapped amount\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _borrowed = vdToken().balanceOf(address(this));\n        uint256 _investedBorrowBalance = _getInvestedBorrowBalance();\n        ILendingPool _lendingPool = aavePoolAddressesProvider().getPool();\n\n        // _borrow increases every block. Convert collateral to borrowToken.\n        if (_borrowed > _investedBorrowBalance) {\n            // Loss making scenario. Convert collateral to borrowToken to repay loss\n            _swapToBorrowToken(_borrowed - _investedBorrowBalance, _lendingPool);\n        } else {\n            // Swap extra borrow token to collateral token and report profit\n            _rebalanceBorrow(_investedBorrowBalance - _borrowed);\n        }\n        uint256 _collateralHere = _getCollateralHere();\n        uint256 _supplied = IERC20(receiptToken()).balanceOf(address(this));\n        uint256 _unwrappedSupplied = _calculateUnwrapped(_supplied);\n        uint256 _totalCollateral = _unwrappedSupplied + _collateralHere;\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_collateralHere < _profitAndExcessDebt) {\n            uint256 _totalAmountToWithdraw = Math.min((_profitAndExcessDebt - _collateralHere), _unwrappedSupplied);\n            if (_totalAmountToWithdraw > 0) {\n                _withdrawHere(_totalAmountToWithdraw, _lendingPool, _borrowed, _supplied);\n                _collateralHere = collateralToken().balanceOf(address(this));\n            }\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n\n        _pool.reportEarning(_profit, _loss, _payback);\n        // This is unwrapped balance if pool supports unwrap token eg stETH\n        uint256 _newSupply = collateralToken().balanceOf(address(this));\n        if (_newSupply > 0) {\n            _depositToAave(_newSupply, _lendingPool);\n        }\n\n        // There are scenarios when we want to call _calculateBorrowPosition and act on it.\n        // 1. Strategy got some collateral from pool which will allow strategy to borrow more.\n        // 2. Collateral and/or borrow token price is changed which leads to repay or borrow.\n        // 3. BorrowLimits are updated.\n        // In some edge scenarios, below call is redundant but keeping it as is for simplicity.\n        (uint256 _borrowAmount, uint256 _repayAmount) = _calculateBorrowPosition(\n            0,\n            0,\n            vdToken().balanceOf(address(this)),\n            IERC20(receiptToken()).balanceOf(address(this))\n        );\n        address _borrowToken = borrowToken();\n        if (_repayAmount > 0) {\n            // Repay _borrowAmount to maintain safe position\n            _repayY(_repayAmount, _lendingPool);\n        } else if (_borrowAmount > 0) {\n            // 2 for variable rate borrow, 0 for referralCode\n            _lendingPool.borrow(_borrowToken, _borrowAmount, 2, 0, address(this));\n        }\n        uint256 _borrowTokenBalance = IERC20(_borrowToken).balanceOf(address(this));\n        if (_borrowTokenBalance > 0) {\n            _afterBorrowY(_borrowTokenBalance);\n        }\n    }\n\n    /// @notice Swap earned borrow token for collateral and report it as profits\n    function _rebalanceBorrow(uint256 excessBorrow_) internal {\n        address _borrowToken = borrowToken();\n        address _wrappedCollateral = address(wrappedCollateral());\n        if (excessBorrow_ > 0) {\n            uint256 _borrowedHere = IERC20(_borrowToken).balanceOf(address(this));\n            if (excessBorrow_ > _borrowedHere) {\n                _withdrawY(excessBorrow_ - _borrowedHere);\n                _borrowedHere = IERC20(_borrowToken).balanceOf(address(this));\n            }\n            if (_borrowedHere > 0) {\n                // Swap minimum of _excessBorrow and _borrowedHere for collateral\n                uint256 _amountIn = Math.min(excessBorrow_, _borrowedHere);\n                uint256 _expectedAmountOut = _quote(_borrowToken, _wrappedCollateral, _amountIn);\n                uint256 _minAmountOut = (_expectedAmountOut * (MAX_BPS - slippage())) / MAX_BPS;\n                swapper().swapExactInput(_borrowToken, _wrappedCollateral, _amountIn, _minAmountOut, address(this));\n            }\n        }\n    }\n\n    function _repayY(uint256 amount_, ILendingPool aaveLendingPool_) internal {\n        _beforeRepayY(amount_);\n        aaveLendingPool_.repay(borrowToken(), amount_, 2, address(this));\n    }\n\n    /**\n     * @dev Swap collateral to borrow token.\n     * @param amountOut_ Expected output of this swap\n     * @param aaveLendingPool_ Aave lending pool instance\n     */\n    function _swapToBorrowToken(uint256 amountOut_, ILendingPool aaveLendingPool_) internal {\n        address _borrowToken = borrowToken();\n        address _wrappedCollateral = address(wrappedCollateral());\n        // Looking for _amountIn using fixed output amount\n        uint256 _expectedAmountIn = _quote(_borrowToken, _wrappedCollateral, amountOut_);\n\n        if (_expectedAmountIn > 0) {\n            uint256 _maxAmountIn = (_expectedAmountIn * (MAX_BPS + slippage())) / MAX_BPS;\n            // Not using unwrapped balance here as those can be used in rebalance reporting via getCollateralHere\n            uint256 _collateralHere = IERC20(_wrappedCollateral).balanceOf(address(this));\n            if (_maxAmountIn > _collateralHere) {\n                // Withdraw some collateral from Aave so that we have enough collateral to get expected output\n                uint256 _amount = _maxAmountIn - _collateralHere;\n                if (aaveLendingPool_.withdraw(_wrappedCollateral, _amount, address(this)) != _amount)\n                    revert IncorrectWithdrawAmount();\n            }\n            swapper().swapExactOutput(_wrappedCollateral, _borrowToken, amountOut_, _maxAmountIn, address(this));\n        }\n    }\n\n    function _unwrap(uint256 wrappedAmount_) internal virtual returns (uint256) {\n        return wrappedAmount_;\n    }\n\n    function _wrap(uint256 unwrappedAmount_) internal virtual returns (uint256) {\n        return unwrappedAmount_;\n    }\n\n    function _withdrawY(uint256 amount_) internal virtual;\n\n    /// @dev If pool supports unwrapped token(stETH) then input and output both are unwrapped token amount.\n    function _withdrawHere(uint256 requireAmount_) internal override {\n        _withdrawHere(\n            requireAmount_,\n            aavePoolAddressesProvider().getPool(),\n            vdToken().balanceOf(address(this)),\n            IERC20(receiptToken()).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @dev If pool supports unwrapped token(stETH) then _requireAmount and output both are unwrapped token amount.\n     * @param requireAmount_ unwrapped collateral amount\n     * @param supplied_ wrapped collateral amount\n     */\n    function _withdrawHere(\n        uint256 requireAmount_,\n        ILendingPool aaveLendingPool_,\n        uint256 borrowed_,\n        uint256 supplied_\n    ) internal {\n        IERC20 _wrappedCollateral = wrappedCollateral();\n        uint256 _wrappedRequireAmount = _calculateWrapped(requireAmount_);\n        (, uint256 _repayAmount) = _calculateBorrowPosition(0, _wrappedRequireAmount, borrowed_, supplied_);\n        if (_repayAmount > 0) {\n            _repayY(_repayAmount, aaveLendingPool_);\n        }\n        // withdraw asking more than available liquidity will fail. To do safe withdraw, check\n        // _wrappedRequireAmount against available liquidity.\n        uint256 _possibleWithdraw = Math.min(\n            _wrappedRequireAmount,\n            Math.min(supplied_, _wrappedCollateral.balanceOf(receiptToken()))\n        );\n        if (\n            aaveLendingPool_.withdraw(address(_wrappedCollateral), _possibleWithdraw, address(this)) !=\n            _possibleWithdraw\n        ) revert IncorrectWithdrawAmount();\n        // Unwrap wrapped tokens\n        _unwrap(_wrappedCollateral.balanceOf(address(this)));\n    }\n\n    /************************************************************************************************\n     *                          Governor/admin/keeper function                                      *\n     ***********************************************************************************************/\n\n    /**\n     * @notice Update upper and lower borrow limit. Usually maxBorrowLimit < 100% of actual collateral factor of protocol.\n     * @dev It is possible to set 0 as _minBorrowLimit to not borrow anything\n     * @param minBorrowLimit_ It is % of actual collateral factor of protocol\n     * @param maxBorrowLimit_ It is % of actual collateral factor of protocol\n     */\n    function updateBorrowLimit(uint256 minBorrowLimit_, uint256 maxBorrowLimit_) external onlyGovernor {\n        if (maxBorrowLimit_ >= MAX_BPS) revert InvalidMaxBorrowLimit();\n\n        // set _maxBorrowLimit and _minBorrowLimit to zero to disable borrow;\n        if ((maxBorrowLimit_ != 0 || minBorrowLimit_ != 0) && maxBorrowLimit_ <= minBorrowLimit_)\n            revert MaxShouldBeHigherThanMin();\n\n        AaveV3BorrowStorage storage $ = _getAaveV3BorrowStorage();\n        emit UpdatedBorrowLimit($._minBorrowLimit, minBorrowLimit_, $._maxBorrowLimit, maxBorrowLimit_);\n        // To avoid liquidation due to price variations maxBorrowLimit is a collateral factor that is less than actual collateral factor of protocol\n        $._minBorrowLimit = minBorrowLimit_;\n        $._maxBorrowLimit = maxBorrowLimit_;\n    }\n\n    function updateSlippage(uint256 newSlippage_) external onlyGovernor {\n        if (newSlippage_ > MAX_BPS) revert InvalidSlippage();\n        AaveV3BorrowStorage storage $ = _getAaveV3BorrowStorage();\n        emit UpdatedSlippage($._slippage, newSlippage_);\n        $._slippage = newSlippage_;\n    }\n}\n"
    },
    "contracts/strategies/aave/v3/AaveV3Incentive.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IAToken} from \"../../../interfaces/aave/IAToken.sol\";\nimport {IIncentivesController} from \"../../../interfaces/aave/IIncentivesController.sol\";\n\n/// @title This contract provide core operations for Aave v3\nlibrary AaveV3Incentive {\n    /**\n     * @notice Claim rewards from Aave incentive controller\n     */\n    function _claimRewards(\n        address aToken_\n    ) internal returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n        // Some aTokens may have no incentive controller method/variable. Better use try catch\n        try IAToken(aToken_).getIncentivesController() returns (IIncentivesController _incentivesController) {\n            address[] memory assets = new address[](1);\n            assets[0] = address(aToken_);\n            return _incentivesController.claimAllRewards(assets, address(this));\n            //solhint-disable-next-line no-empty-blocks\n        } catch {}\n    }\n}\n"
    },
    "contracts/strategies/aave/v3/AaveV3SommelierBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {ICellar} from \"../../../interfaces/sommelier/ISommelier.sol\";\nimport {SommelierBase} from \"../../sommelier/SommelierBase.sol\";\nimport {AaveV3Borrow} from \"./AaveV3Borrow.sol\";\n\n/// @title Deposit Collateral in Aave and earn yield by depositing borrowed token in a Sommelier Vault.\ncontract AaveV3SommelierBorrow is AaveV3Borrow, SommelierBase {\n    using SafeERC20 for IERC20;\n\n    error InvalidSommelierVault();\n\n    function initialize(\n        address _pool,\n        address _swapper,\n        address _receiptToken,\n        address _borrowToken,\n        address _aaveAddressProvider,\n        address _cellar,\n        string memory _name\n    ) public initializer {\n        __AaveV3Borrow_init(_pool, _swapper, _receiptToken, _borrowToken, _aaveAddressProvider, _name);\n        __Sommelier_init(_cellar);\n        if (ICellar(_cellar).asset() != borrowToken()) revert InvalidSommelierVault();\n    }\n\n    /// @dev After borrowing Y, deposit to Sommelier vault\n    function _afterBorrowY(uint256 _amount) internal  override {\n        _depositInSommelier(_amount);\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 _amount) internal virtual override {\n        super._approveToken(_amount);\n        IERC20(borrowToken()).forceApprove(address(cellar()), _amount);\n    }\n\n    /// @dev Before repaying Y, withdraw it from Sommelier vault\n\n    function _beforeRepayY(uint256 _amount) internal  override {\n        _withdrawY(_amount);\n    }\n\n    /// @notice Withdraw _shares proportional to collateral _amount from vPool\n    function _withdrawY(uint256 _amount) internal  override {\n        _withdrawFromSommelier(_amount);\n    }\n\n    /// @dev borrowToken balance here + borrowToken balance deposited in Sommelier vault\n    function _getInvestedBorrowBalance() internal view  override returns (uint256) {\n        return IERC20(borrowToken()).balanceOf(address(this)) + _getAssetsInSommelier();\n    }\n}\n"
    },
    "contracts/strategies/aave/v3/AaveV3SommelierBorrowForStETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IWstETH} from \"../../../interfaces/lido/IWstETH.sol\";\nimport {AaveV3SommelierBorrow} from \"./AaveV3SommelierBorrow.sol\";\n\n/// @title Deposit wstETH in Aave and earn yield by depositing borrowed token in a Sommelier vault.\ncontract AaveV3SommelierBorrowForStETH is AaveV3SommelierBorrow {\n    using SafeERC20 for IERC20;\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.AaveV3SommelierBorrow.stETH\n    struct AaveV3SommelierBorrowForStETHStorage {\n        IWstETH _wstETH;\n    }\n\n    bytes32 private constant AaveV3SommelierBorrowForStETHStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.AaveV3SommelierBorrow.stETH\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getAaveV3SommelierBorrowForStETHStorage()\n        internal\n        pure\n        returns (AaveV3SommelierBorrowForStETHStorage storage $)\n    {\n        bytes32 _location = AaveV3SommelierBorrowForStETHStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function AaveV3SommelierBorrowForStETH_initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        address borrowToken_,\n        address poolAddressesProvider_,\n        address vPool_,\n        address wstETH_,\n        string memory name_\n    ) external initializer {\n        // Set wstETH before calling init on parent contract\n        if (wstETH_ == address(0)) revert AddressIsNull();\n        _getAaveV3SommelierBorrowForStETHStorage()._wstETH = IWstETH(wstETH_);\n\n        super.initialize(pool_, swapper_, receiptToken_, borrowToken_, poolAddressesProvider_, vPool_, name_);\n    }\n\n    function wstETH() public view returns (IWstETH) {\n        return _getAaveV3SommelierBorrowForStETHStorage()._wstETH;\n    }\n\n    /// @notice Returns total collateral locked in the strategy\n    function tvl() external view  override returns (uint256) {\n        // receiptToken is aToken. aToken is 1:1 of collateral token\n        return\n            IERC20(receiptToken()).balanceOf(address(this)) +\n            wrappedCollateral().balanceOf(address(this)) +\n            _calculateWrapped(collateralToken().balanceOf(address(this)));\n    }\n\n    function _approveToken(uint256 amount_) internal  override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(wrappedCollateral()), amount_);\n    }\n\n    function _calculateUnwrapped(uint256 wrappedAmount_) internal view override returns (uint256) {\n        return wstETH().getStETHByWstETH(wrappedAmount_);\n    }\n\n    function _calculateWrapped(uint256 unwrappedAmount_) internal view override returns (uint256) {\n        return wstETH().getWstETHByStETH(unwrappedAmount_);\n    }\n\n    function _getCollateralHere() internal  override returns (uint256) {\n        uint256 _wrapped = wrappedCollateral().balanceOf(address(this));\n        if (_wrapped > 0) {\n            _unwrap(_wrapped);\n        }\n        // Return unwrapped balance\n        return collateralToken().balanceOf(address(this));\n    }\n\n    function _getWrappedToken(IERC20) internal view override returns (IERC20) {\n        return IERC20(address(wstETH()));\n    }\n\n    function _unwrap(uint256 wrappedAmount_) internal override returns (uint256) {\n        return wstETH().unwrap(wrappedAmount_);\n    }\n\n    function _wrap(uint256 unwrappedAmount_) internal override returns (uint256) {\n        return wstETH().wrap(unwrappedAmount_);\n    }\n}\n"
    },
    "contracts/strategies/aave/v3/AaveV3VesperBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {AaveV3Borrow} from \"./AaveV3Borrow.sol\";\n\n/// @title Deposit Collateral in Aave and earn interest by depositing borrowed token in a Vesper Pool.\ncontract AaveV3VesperBorrow is AaveV3Borrow {\n    using SafeERC20 for IERC20;\n\n    error InvalidGrowPool();\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.AaveV3VesperBorrow\n    struct AaveV3VesperBorrowStorage {\n        IVesperPool _vPool;\n    }\n\n    bytes32 private constant AaveV3VesperBorrowStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.AaveV3VesperBorrow\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getAaveV3VesperBorrowStorage() internal pure returns (AaveV3VesperBorrowStorage storage $) {\n        bytes32 _location = AaveV3VesperBorrowStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        address borrowToken_,\n        address poolAddressesProvider_,\n        address vPool_,\n        string memory name_\n    ) public initializer {\n        __AaveV3Borrow_init(pool_, swapper_, receiptToken_, borrowToken_, poolAddressesProvider_, name_);\n        if (address(IVesperPool(vPool_).token()) != borrowToken()) revert InvalidGrowPool();\n        _getAaveV3VesperBorrowStorage()._vPool = IVesperPool(vPool_);\n    }\n\n    function isReservedToken(address token_) public view override returns (bool) {\n        return super.isReservedToken(token_) || token_ == address(vPool());\n    }\n\n    function vPool() public view returns (IVesperPool) {\n        return _getAaveV3VesperBorrowStorage()._vPool;\n    }\n\n    /// @notice After borrowing Y, deposit to Vesper Pool\n    function _afterBorrowY(uint256 amount_) internal override {\n        vPool().deposit(amount_);\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal virtual override {\n        super._approveToken(amount_);\n        IVesperPool _vPool = vPool();\n        IERC20(borrowToken()).forceApprove(address(_vPool), amount_);\n    }\n\n    /// @notice Before repaying Y, withdraw it from Vesper Pool\n    function _beforeRepayY(uint256 amount_) internal override {\n        _withdrawY(amount_);\n    }\n\n    /// @dev borrowToken balance here + borrowToken balance deposited in Vesper Pool\n    function _getInvestedBorrowBalance() internal view override returns (uint256) {\n        IVesperPool _vPool = vPool();\n        return\n            IERC20(borrowToken()).balanceOf(address(this)) +\n            ((_vPool.pricePerShare() * _vPool.balanceOf(address(this))) / 1e18);\n    }\n\n    /// @notice Withdraw _shares proportional to collateral amount_ from vPool\n    function _withdrawY(uint256 amount_) internal override {\n        IVesperPool _vPool = vPool();\n        if (amount_ > 0) {\n            uint256 _pricePerShare = _vPool.pricePerShare();\n            uint256 _shares = (amount_ * 1e18) / _pricePerShare;\n            _shares = amount_ > ((_shares * _pricePerShare) / 1e18) ? _shares + 1 : _shares;\n            _shares = Math.min(_shares, _vPool.balanceOf(address(this)));\n            if (_shares > 0) {\n                _vPool.withdraw(_shares);\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/aave/v3/AaveV3VesperBorrowForStETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IWstETH} from \"../../../interfaces/lido/IWstETH.sol\";\nimport {AaveV3VesperBorrow} from \"./AaveV3VesperBorrow.sol\";\n\n/// @title Deposit wstETH in Aave and earn yield by depositing borrowed token in a Vesper Pool.\ncontract AaveV3VesperBorrowForStETH is AaveV3VesperBorrow {\n    using SafeERC20 for IERC20;\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.AaveV3VesperBorrow.stETH\n    struct AaveV3VesperBorrowForStETHStorage {\n        IWstETH _wstETH;\n    }\n\n    bytes32 private constant AaveV3VesperBorrowForStETHStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.AaveV3VesperBorrow.stETH\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getAaveV3VesperBorrowForStETHStorage()\n        internal\n        pure\n        returns (AaveV3VesperBorrowForStETHStorage storage $)\n    {\n        bytes32 _location = AaveV3VesperBorrowForStETHStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function AaveV3VesperBorrowForStETH_initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        address borrowToken_,\n        address poolAddressesProvider_,\n        address vPool_,\n        address wstETH_,\n        string memory name_\n    ) external initializer {\n        // Set wstETH before calling init on parent contract\n        if (wstETH_ == address(0)) revert AddressIsNull();\n        _getAaveV3VesperBorrowForStETHStorage()._wstETH = IWstETH(wstETH_);\n\n        super.initialize(pool_, swapper_, receiptToken_, borrowToken_, poolAddressesProvider_, vPool_, name_);\n    }\n\n    function wstETH() public view returns (IWstETH) {\n        return _getAaveV3VesperBorrowForStETHStorage()._wstETH;\n    }\n\n    /// @notice Returns total collateral locked in the strategy\n    function tvl() external view override returns (uint256) {\n        // receiptToken is aToken. aToken is 1:1 of collateral token\n        return\n            IERC20(receiptToken()).balanceOf(address(this)) +\n            wrappedCollateral().balanceOf(address(this)) +\n            _calculateWrapped(collateralToken().balanceOf(address(this)));\n    }\n\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(wrappedCollateral()), amount_);\n    }\n\n    function _calculateUnwrapped(uint256 wrappedAmount_) internal view override returns (uint256) {\n        return wstETH().getStETHByWstETH(wrappedAmount_);\n    }\n\n    function _calculateWrapped(uint256 unwrappedAmount_) internal view override returns (uint256) {\n        return wstETH().getWstETHByStETH(unwrappedAmount_);\n    }\n\n    function _getCollateralHere() internal override  returns (uint256) {\n        uint256 _wrapped = wrappedCollateral().balanceOf(address(this));\n        if (_wrapped > 0) {\n            _unwrap(_wrapped);\n        }\n        // Return unwrapped balance\n        return collateralToken().balanceOf(address(this));\n    }\n\n    function _getWrappedToken(IERC20) internal view override returns (IERC20) {\n        return IERC20(address(wstETH()));\n    }\n\n    function _unwrap(uint256 wrappedAmount_) internal override returns (uint256) {\n        return wstETH().unwrap(wrappedAmount_);\n    }\n\n    function _wrap(uint256 unwrappedAmount_) internal override returns (uint256) {\n        return wstETH().wrap(unwrappedAmount_);\n    }\n}\n"
    },
    "contracts/strategies/compound/v3/CompoundV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../../Strategy.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {IComet} from \"../../../interfaces/compound/IComet.sol\";\n\n/// @title This strategy will deposit base asset i.e. USDC in Compound V3 and earn interest.\ncontract CompoundV3 is Strategy {\n    using SafeERC20 for IERC20;\n\n    function initialize(address pool_, address swapper_, address comet_, string memory name_) external initializer {\n        __Strategy_init(pool_, swapper_, comet_, name_);\n    }\n\n    function comet() public view returns (IComet) {\n        return IComet(receiptToken());\n    }\n\n    function tvl() external view override returns (uint256) {\n        return comet().balanceOf(address(this)) + collateralToken().balanceOf(address(this));\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(comet()), amount_);\n    }\n\n    /**\n     * @dev Deposit collateral in Compound.\n     */\n    function _deposit(uint256 amount_) internal {\n        if (amount_ > 0) {\n            comet().supply(address(collateralToken()), amount_);\n        }\n    }\n\n    function _getAvailableLiquidity() internal view returns (uint256) {\n        IComet _comet = comet();\n        uint256 _totalSupply = _comet.totalSupply();\n        uint256 _totalBorrow = _comet.totalBorrow();\n        return _totalSupply > _totalBorrow ? _totalSupply - _totalBorrow : 0;\n    }\n\n    /**\n     * @dev Generate report for pools accounting and also send profit and any payback to pool.\n     */\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _collateralHere + comet().balanceOf(address(this));\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        IVesperPool(_pool).reportEarning(_profit, _loss, _payback);\n        // After reportEarning strategy may get more collateral from pool. Deposit those in Compound.\n        _deposit(_collateralToken.balanceOf(address(this)));\n    }\n\n    /// @dev Withdraw collateral here. Do not transfer to pool\n    function _withdrawHere(uint256 amount_) internal override {\n        IComet _comet = comet();\n        // Get minimum of _amount and _available collateral and _availableLiquidity\n        uint256 _withdrawAmount = Math.min(\n            amount_,\n            Math.min(_comet.balanceOf(address(this)), _getAvailableLiquidity())\n        );\n        _comet.withdraw(address(collateralToken()), _withdrawAmount);\n    }\n}\n"
    },
    "contracts/strategies/compound/v3/CompoundV3Borrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../../Strategy.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {ISwapper} from \"../../../interfaces/swapper/ISwapper.sol\";\nimport {IComet} from \"../../../interfaces/compound/IComet.sol\";\n\n// solhint-disable no-empty-blocks\n\n/// @title This is base strategy for CompoundV3 borrow.\n/// This strategy will deposit collateral token in Compound V3 and based on position it will\n/// borrow based token. Supply X borrow Y and keep borrowed amount here.\nabstract contract CompoundV3Borrow is Strategy {\n    using SafeERC20 for IERC20;\n\n    error InvalidInput();\n    error InvalidMaxBorrowLimit();\n    error MaxShouldBeHigherThanMin();\n\n    event UpdatedBorrowLimit(\n        uint256 previousMinBorrowLimit,\n        uint256 newMinBorrowLimit,\n        uint256 previousMaxBorrowLimit,\n        uint256 newMaxBorrowLimit\n    );\n\n    uint256 internal constant MAX_BPS = 10_000; //100%\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.CompoundV3Borrow\n    struct CompoundV3BorrowStorage {\n        IComet _comet;\n        address _borrowToken;\n        uint256 _minBorrowLimit;\n        uint256 _maxBorrowLimit;\n    }\n\n    bytes32 private constant CompoundV3BorrowStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.CompoundV3Borrow\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getCompoundV3BorrowStorage() internal pure returns (CompoundV3BorrowStorage storage $) {\n        bytes32 _location = CompoundV3BorrowStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function __CompoundV3Borrow_init(\n        address pool_,\n        address swapper_,\n        address comet_,\n        address borrowToken_,\n        string memory name_\n    ) internal initializer {\n        __Strategy_init(pool_, swapper_, comet_, name_);\n        if (borrowToken_ == address(0)) revert AddressIsNull();\n\n        CompoundV3BorrowStorage storage $ = _getCompoundV3BorrowStorage();\n        $._comet = IComet(comet_);\n        $._borrowToken = borrowToken_;\n        $._minBorrowLimit = 7_000; // 70% of actual collateral factor of protocol\n        $._maxBorrowLimit = 8_500; // 85% of actual collateral factor of protocol\n    }\n\n    function borrowToken() public view returns (address) {\n        return _getCompoundV3BorrowStorage()._borrowToken;\n    }\n\n    function comet() public view returns (IComet) {\n        return _getCompoundV3BorrowStorage()._comet;\n    }\n\n    function isReservedToken(address token_) public view virtual override returns (bool) {\n        return super.isReservedToken(token_) || token_ == borrowToken();\n    }\n\n    function maxBorrowLimit() public view returns (uint256) {\n        return _getCompoundV3BorrowStorage()._maxBorrowLimit;\n    }\n\n    function minBorrowLimit() public view returns (uint256) {\n        return _getCompoundV3BorrowStorage()._minBorrowLimit;\n    }\n\n    /// @notice Returns total collateral locked in the strategy\n    function tvl() external view override returns (uint256) {\n        IERC20 _collateralToken = collateralToken();\n        return\n            comet().collateralBalanceOf(address(this), address(_collateralToken)) +\n            _collateralToken.balanceOf(address(this));\n    }\n\n    /// @dev Hook that executes after collateral borrow.\n    function _afterBorrowY(uint256 amount_) internal virtual {}\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal virtual override {\n        super._approveToken(amount_);\n        address _swapper = address(swapper());\n        address _comet = address(comet());\n        IERC20 _collateralToken = collateralToken();\n        IERC20 _borrowToken = IERC20(borrowToken());\n        _collateralToken.forceApprove(_comet, amount_);\n        _collateralToken.forceApprove(_swapper, amount_);\n        _borrowToken.forceApprove(_comet, amount_);\n        _borrowToken.forceApprove(_swapper, amount_);\n    }\n\n    /// @dev Borrow Y from Compound. _afterBorrowY hook can be used to do anything with borrowed amount.\n    /// @dev Override to handle ETH\n    function _borrowY(uint256 amount_) internal {\n        if (amount_ > 0) {\n            comet().withdraw(borrowToken(), amount_);\n            _afterBorrowY(amount_);\n        }\n    }\n\n    /**\n     * @notice Calculate borrow and repay amount based on current collateral and new deposit/withdraw amount.\n     * @param depositAmount_ deposit amount\n     * @param withdrawAmount_ withdraw amount\n     * @return _borrowAmount borrow more amount\n     * @return _repayAmount repay amount to keep ltv within limits\n     */\n    function _calculateBorrowPosition(\n        uint256 depositAmount_,\n        uint256 withdrawAmount_\n    ) internal view returns (uint256 _borrowAmount, uint256 _repayAmount) {\n        if (depositAmount_ != 0 && withdrawAmount_ != 0) revert InvalidInput();\n        IComet _comet = comet();\n        address _collateralToken = address(collateralToken());\n        uint256 _borrowed = _comet.borrowBalanceOf(address(this));\n        // If maximum borrow limit set to 0 then repay borrow\n        if (maxBorrowLimit() == 0) {\n            return (0, _borrowed);\n        }\n\n        uint256 _collateralSupplied = _comet.collateralBalanceOf(address(this), _collateralToken);\n\n        // In case of withdraw, withdrawAmount_ may be greater than _collateralSupplied\n        uint256 _hypotheticalCollateral;\n        if (depositAmount_ > 0) {\n            _hypotheticalCollateral = _collateralSupplied + depositAmount_;\n        } else if (_collateralSupplied > withdrawAmount_) {\n            _hypotheticalCollateral = _collateralSupplied - withdrawAmount_;\n        }\n\n        IComet.AssetInfo memory _collateralInfo = _comet.getAssetInfoByAddress(_collateralToken);\n\n        // Compound V3 is using chainlink for price feed. Feed has 8 decimals\n        uint256 _collateralTokenPrice = _comet.getPrice(_collateralInfo.priceFeed);\n        uint256 _borrowTokenPrice = _comet.getPrice(_comet.baseTokenPriceFeed());\n\n        // Calculate max borrow based on collateral factor. CF is 18 decimal based\n        uint256 _collateralForBorrowInUSD = (_hypotheticalCollateral *\n            _collateralTokenPrice *\n            _collateralInfo.borrowCollateralFactor) / (1e18 * 10 ** IERC20Metadata(_collateralToken).decimals());\n\n        // Max borrow limit in borrow token\n        uint256 _maxBorrowPossible = (_collateralForBorrowInUSD * 10 ** IERC20Metadata(borrowToken()).decimals()) /\n            _borrowTokenPrice;\n        // If maxBorrow is zero, we should repay total amount of borrow\n        if (_maxBorrowPossible == 0) {\n            return (0, _borrowed);\n        }\n\n        // Safe buffer to avoid liquidation due to price variations.\n        uint256 _borrowUpperBound = (_maxBorrowPossible * maxBorrowLimit()) / MAX_BPS;\n\n        // Borrow up to _borrowLowerBound and keep buffer of _borrowUpperBound - _borrowLowerBound for price variation\n        uint256 _borrowLowerBound = (_maxBorrowPossible * minBorrowLimit()) / MAX_BPS;\n\n        // If current borrow is greater than max borrow, then repay to achieve safe position else borrow more.\n        if (_borrowed > _borrowUpperBound) {\n            // If borrow > upperBound then it is greater than lowerBound too.\n            _repayAmount = _borrowed - _borrowLowerBound;\n        } else if (_borrowLowerBound > _borrowed) {\n            _borrowAmount = _borrowLowerBound - _borrowed;\n            uint256 _availableLiquidity = _getAvailableLiquidity();\n            if (_borrowAmount > _availableLiquidity) {\n                _borrowAmount = _availableLiquidity;\n            }\n        }\n    }\n\n    /// @dev Deposit collateral in Compound V3 and adjust borrow position\n    function _deposit() internal {\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralBalance = _collateralToken.balanceOf(address(this));\n        (uint256 _borrowAmount, uint256 _repayAmount) = _calculateBorrowPosition(_collateralBalance, 0);\n        if (_repayAmount > 0) {\n            // Repay to maintain safe position\n            _repay(_repayAmount);\n            _mintX(_collateralToken.balanceOf(address(this)));\n        } else {\n            // Happy path, mint more borrow more\n            _mintX(_collateralBalance);\n            _borrowY(_borrowAmount);\n        }\n    }\n\n    function _getAvailableLiquidity() internal view returns (uint256) {\n        IComet _comet = comet();\n        uint256 _totalSupply = _comet.totalSupply();\n        uint256 _totalBorrow = _comet.totalBorrow();\n        return _totalSupply > _totalBorrow ? _totalSupply - _totalBorrow : 0;\n    }\n\n    function _getYTokensInProtocol() internal view virtual returns (uint256) {}\n\n    /// @dev Deposit collateral aka X in Compound. Override to handle ETH\n    function _mintX(uint256 amount_) internal {\n        if (amount_ > 0) {\n            comet().supply(address(collateralToken()), amount_);\n        }\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        IComet _comet = comet();\n        {\n            address _borrowToken = borrowToken();\n            uint256 _yTokensBorrowed = _comet.borrowBalanceOf(address(this));\n            uint256 _yTokensHere = IERC20(_borrowToken).balanceOf(address(this));\n            uint256 _yTokensInProtocol = _getYTokensInProtocol();\n            uint256 _totalYTokens = _yTokensHere + _yTokensInProtocol;\n\n            // _borrow increases every block. Convert collateral to borrowToken.\n            if (_yTokensBorrowed > _totalYTokens) {\n                _swapToBorrowToken(_yTokensBorrowed - _totalYTokens);\n            } else {\n                // When _yTokensInProtocol exceeds _yTokensBorrowed from Compound\n                // then we have profit from investing borrow tokens. _yTokensHere is profit.\n                if (_yTokensInProtocol > _yTokensBorrowed) {\n                    _withdrawY(_yTokensInProtocol - _yTokensBorrowed);\n                    _yTokensHere = IERC20(_borrowToken).balanceOf(address(this));\n                }\n                if (_yTokensHere > 0) {\n                    _trySwapExactInput(_borrowToken, address(_collateralToken), _yTokensHere);\n                }\n            }\n        }\n\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _collateralHere +\n            _comet.collateralBalanceOf(address(this), address(_collateralToken));\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_collateralHere < _profitAndExcessDebt) {\n            uint256 _totalAmountToWithdraw = _profitAndExcessDebt - _collateralHere;\n            if (_totalAmountToWithdraw > 0) {\n                _withdrawHere(_totalAmountToWithdraw);\n                _collateralHere = _collateralToken.balanceOf(address(this));\n            }\n        }\n        // Set actual payback first and then profit. Make sure _collateralHere >= _payback + profit.\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        _pool.reportEarning(_profit, _loss, _payback);\n\n        _deposit();\n    }\n\n    /**\n     * @dev Repay borrow amount\n     * @dev Swap collateral to borrowToken as needed.\n     * @param repayAmount_ BorrowToken amount that we should repay to maintain safe position.\n     */\n    function _repay(uint256 repayAmount_) internal {\n        if (repayAmount_ > 0) {\n            uint256 _totalYTokens = IERC20(borrowToken()).balanceOf(address(this)) + _getYTokensInProtocol();\n            // Liability is more than what we have.\n            // To repay loan - convert all rewards to collateral, if asked, and redeem collateral(if needed).\n            // This scenario is rare and if system works okay it will/might happen during final repay only.\n            if (repayAmount_ > _totalYTokens) {\n                uint256 _yTokensBorrowed = comet().borrowBalanceOf(address(this));\n                // For example this is final repay and 100 blocks has passed since last withdraw/rebalance,\n                // _yTokensBorrowed is increasing due to interest. Now if _repayAmount > _borrowBalanceHere is true\n                // _yTokensBorrowed > _borrowBalanceHere is also true.\n                // To maintain safe position we always try to keep _yTokensBorrowed = _borrowBalanceHere\n\n                // Swap collateral to borrowToken to repay borrow and also maintain safe position\n                // Here borrowToken amount needed is (_yTokensBorrowed - _borrowBalanceHere)\n                _swapToBorrowToken(_yTokensBorrowed - _totalYTokens);\n            }\n            _repayY(repayAmount_);\n        }\n    }\n\n    /// @dev Repay Y to Compound V3. Withdraw Y from end protocol if applicable.\n    /// @dev Override this to handle ETH\n    function _repayY(uint256 amount_) internal {\n        _withdrawY(amount_);\n        comet().supply(borrowToken(), amount_);\n    }\n\n    /**\n     * @dev Swap given token to borrowToken\n     * @param shortOnBorrow_ Expected output of this swap\n     */\n    function _swapToBorrowToken(uint256 shortOnBorrow_) internal {\n        // Looking for _amountIn using fixed output amount\n        IERC20 _collateralToken = collateralToken();\n        address _borrowToken = borrowToken();\n        ISwapper _swapper = swapper();\n        uint256 _amountIn = _swapper.getAmountIn(address(_collateralToken), _borrowToken, shortOnBorrow_);\n        if (_amountIn > 0) {\n            uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n            // If we do not have enough _from token to get expected output, either get\n            // some _from token or adjust expected output.\n            if (_amountIn > _collateralHere) {\n                // Redeem some collateral, so that we have enough collateral to get expected output\n                comet().withdraw(address(_collateralToken), _amountIn - _collateralHere);\n            }\n            _swapper.swapExactOutput(address(_collateralToken), _borrowToken, shortOnBorrow_, _amountIn, address(this));\n        }\n    }\n\n    /// @dev Withdraw collateral here. Do not transfer to pool\n    function _withdrawHere(uint256 amount_) internal override {\n        (, uint256 _repayAmount) = _calculateBorrowPosition(0, amount_);\n        _repay(_repayAmount);\n        IComet _comet = comet();\n        address _collateralToken = address(collateralToken());\n        // Get minimum of amount_ and collateral supplied and _availableLiquidity of collateral\n        uint256 _withdrawAmount = Math.min(\n            amount_,\n            Math.min(\n                _comet.collateralBalanceOf(address(this), _collateralToken),\n                _comet.totalsCollateral(_collateralToken).totalSupplyAsset\n            )\n        );\n        _comet.withdraw(_collateralToken, _withdrawAmount);\n    }\n\n    function _withdrawY(uint256 _amount) internal virtual {}\n\n    /************************************************************************************************\n     *                          Governor/admin/keeper function                                      *\n     ***********************************************************************************************/\n    /**\n     * @notice Recover extra borrow tokens from strategy\n     * @dev If we get liquidation in Compound, we will have borrowToken sitting in strategy.\n     * This function allows to recover idle borrow token amount.\n     * @param amountToRecover_ Amount of borrow token we want to recover in 1 call.\n     *      Set it 0 to recover all available borrow tokens\n     */\n    function recoverBorrowToken(uint256 amountToRecover_) external onlyKeeper {\n        IERC20 _collateralToken = collateralToken();\n        address _borrowToken = borrowToken();\n        uint256 _borrowBalanceHere = IERC20(_borrowToken).balanceOf(address(this));\n        uint256 _borrowInCompound = comet().borrowBalanceOf(address(this));\n\n        if (_borrowBalanceHere > _borrowInCompound) {\n            uint256 _extraBorrowBalance = _borrowBalanceHere - _borrowInCompound;\n            uint256 _recoveryAmount = (amountToRecover_ > 0 && _extraBorrowBalance > amountToRecover_)\n                ? amountToRecover_\n                : _extraBorrowBalance;\n            // Do swap and transfer\n            uint256 _amountOut = _trySwapExactInput(_borrowToken, address(_collateralToken), _recoveryAmount);\n            if (_amountOut > 0) {\n                _collateralToken.safeTransfer(pool(), _amountOut);\n            }\n        }\n    }\n\n    /**\n     * @notice Repay all borrow amount and set min borrow limit to 0.\n     * @dev This action usually done when loss is detected in strategy.\n     * @dev 0 borrow limit make sure that any future rebalance do not borrow again.\n     */\n    function repayAll() external onlyKeeper {\n        CompoundV3BorrowStorage storage $ = _getCompoundV3BorrowStorage();\n        _repay($._comet.borrowBalanceOf(address(this)));\n        $._minBorrowLimit = 0;\n        $._maxBorrowLimit = 0;\n    }\n\n    /**\n     * @notice Update upper and lower borrow limit. Usually maxBorrowLimit < 100% of actual collateral factor of protocol.\n     * @dev It is possible to set 0 as _minBorrowLimit to not borrow anything\n     * @param minBorrowLimit_ It is % of actual collateral factor of protocol\n     * @param maxBorrowLimit_ It is % of actual collateral factor of protocol\n     */\n    function updateBorrowLimit(uint256 minBorrowLimit_, uint256 maxBorrowLimit_) external onlyGovernor {\n        if (maxBorrowLimit_ >= MAX_BPS) revert InvalidMaxBorrowLimit();\n\n        // set _maxBorrowLimit and _minBorrowLimit to zero to disable borrow;\n        if ((maxBorrowLimit_ != 0 || minBorrowLimit_ != 0) && maxBorrowLimit_ <= minBorrowLimit_)\n            revert MaxShouldBeHigherThanMin();\n\n        CompoundV3BorrowStorage storage $ = _getCompoundV3BorrowStorage();\n        emit UpdatedBorrowLimit($._minBorrowLimit, minBorrowLimit_, $._maxBorrowLimit, maxBorrowLimit_);\n        // To avoid liquidation due to price variations maxBorrowLimit is a collateral factor that is less than actual collateral factor of protocol\n        $._minBorrowLimit = minBorrowLimit_;\n        $._maxBorrowLimit = maxBorrowLimit_;\n    }\n}\n"
    },
    "contracts/strategies/compound/v3/CompoundV3BorrowMain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {CompoundV3Borrow} from \"./CompoundV3Borrow.sol\";\n\n/// @title This strategy will deposit collateral token in Compound V3 and based on position it will\n/// borrow based token. Supply X borrow Y and keep borrowed amount here.\n/// It does not handle ETH as collateral\ncontract CompoundV3BorrowMain is CompoundV3Borrow {\n    function initialize(\n        address pool_,\n        address swapper_,\n        address comet_,\n        address borrowToken_,\n        string memory name_\n    ) public initializer {\n        __CompoundV3Borrow_init(pool_, swapper_, comet_, borrowToken_, name_);\n    }\n}\n"
    },
    "contracts/strategies/compound/v3/CompoundV3VesperBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {CompoundV3Borrow} from \"./CompoundV3Borrow.sol\";\n\n/// @title Deposit Collateral in Compound and earn interest by depositing borrowed token in a Vesper Pool.\ncontract CompoundV3VesperBorrow is CompoundV3Borrow {\n    using SafeERC20 for IERC20;\n\n    error InvalidGrowPool();\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.CompoundV3VesperBorrow\n    struct CompoundV3VesperBorrowStorage {\n        IVesperPool _vPool;\n    }\n\n    bytes32 private constant CompoundV3VesperBorrowStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.CompoundV3VesperBorrow\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getCompoundV3VesperBorrowStorage() internal pure returns (CompoundV3VesperBorrowStorage storage $) {\n        bytes32 _location = CompoundV3VesperBorrowStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address comet_,\n        address borrowToken_,\n        address vPool_,\n        string memory name_\n    ) external initializer {\n        __CompoundV3Borrow_init(pool_, swapper_, comet_, borrowToken_, name_);\n        if (address(IVesperPool(vPool_).token()) != borrowToken()) revert InvalidGrowPool();\n        _getCompoundV3VesperBorrowStorage()._vPool = IVesperPool(vPool_);\n    }\n\n    /// @notice Gets amount of borrowed Y collateral in strategy + Y collateral amount deposited in vPool\n    function borrowBalance() external view returns (uint256) {\n        return IERC20(borrowToken()).balanceOf(address(this)) + _getYTokensInProtocol();\n    }\n\n    function isReservedToken(address token_) public view override returns (bool) {\n        return super.isReservedToken(token_) || token_ == address(vPool());\n    }\n\n    /// @notice Destination Grow Pool for borrowed Token\n    function vPool() public view returns (IVesperPool) {\n        return _getCompoundV3VesperBorrowStorage()._vPool;\n    }\n\n    /// @notice After borrowing Y, deposit to Vesper Pool\n    function _afterBorrowY(uint256 amount_) internal override {\n        vPool().deposit(amount_);\n    }\n\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        IVesperPool _vPool = vPool();\n        IERC20(borrowToken()).forceApprove(address(_vPool), amount_);\n    }\n\n    function _getYTokensInProtocol() internal view override returns (uint256) {\n        IVesperPool _vPool = vPool();\n        return (_vPool.pricePerShare() * _vPool.balanceOf(address(this))) / 1e18;\n    }\n\n    /// @notice Withdraw _shares proportional to collateral _amount from vPool\n    function _withdrawY(uint256 amount_) internal override {\n        IVesperPool _vPool = vPool();\n        uint256 _pricePerShare = _vPool.pricePerShare();\n        uint256 _shares = (amount_ * 1e18) / _pricePerShare;\n        _shares = amount_ > ((_shares * _pricePerShare) / 1e18) ? _shares + 1 : _shares;\n        uint256 _maxShares = _vPool.balanceOf(address(this));\n        _shares = _shares > _maxShares ? _maxShares : _shares;\n        if (_shares > 0) {\n            _vPool.withdraw(_shares);\n        }\n    }\n}\n"
    },
    "contracts/strategies/convex/Convex.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ILiquidityGaugeV2} from \"../../interfaces/curve/ILiquidityGauge.sol\";\nimport {IConvex, IRewards} from \"../../interfaces/convex/IConvexForCurve.sol\";\nimport {CurveBase} from \"../curve/CurveBase.sol\";\n\n// Convex Strategy\ncontract Convex is CurveBase {\n    using SafeERC20 for IERC20;\n\n    error BoosterDepositFailed();\n    error IncorrectLpToken();\n    error RewardClaimFailed();\n    error UnstakeFromConvexFailed();\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.Convex\n    struct ConvexStorage {\n        address _convexToken;\n        IConvex _booster;\n        IRewards _convexRewards;\n        uint256 _convexPoolId;\n    }\n\n    bytes32 private constant ConvexStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.Convex\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getConvexStorage() internal pure returns (ConvexStorage storage $) {\n        bytes32 _location = ConvexStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        CurveBase.CurveInitParams memory params_,\n        IConvex booster_,\n        uint256 convexPoolId_\n    ) external initializer {\n        __CurveBase_init(params_);\n\n        if (address(booster_) == address(0)) revert AddressIsNull();\n\n        (address _lp, , , address _rewards, , ) = booster_.poolInfo(convexPoolId_);\n        if (_lp != address(receiptToken())) revert IncorrectLpToken();\n\n        ConvexStorage storage $ = _getConvexStorage();\n        $._booster = booster_;\n        $._convexRewards = IRewards(_rewards);\n        $._convexPoolId = convexPoolId_;\n    }\n\n    function booster() public view returns (IConvex) {\n        return _getConvexStorage()._booster;\n    }\n\n    function convexPoolId() public view returns (uint256) {\n        return _getConvexStorage()._convexPoolId;\n    }\n\n    function convexRewards() public view returns (IRewards) {\n        return _getConvexStorage()._convexRewards;\n    }\n\n    function convexToken() public view returns (address) {\n        return _getConvexStorage()._convexToken;\n    }\n\n    function lpBalanceStaked() public view override returns (uint256 _total) {\n        _total = convexRewards().balanceOf(address(this));\n    }\n\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        curveLp().forceApprove(address(booster()), amount_);\n    }\n\n    function _deposit() internal override {\n        // 1. deposit collateral in Curve and stake LP in Curve Gauge.\n        super._deposit();\n\n        // 2. Unstake LP from Curve Gauge\n        _unstakeLpFromCurve();\n\n        // 3. Stake LP in Convex Booster\n        uint256 _balance = curveLp().balanceOf(address(this));\n        if (_balance > 0) {\n            if (!booster().deposit(convexPoolId(), _balance, true)) revert BoosterDepositFailed();\n        }\n    }\n\n    function _unstakeLpFromCurve() internal {\n        ILiquidityGaugeV2 _curveGauge = curveGauge();\n        uint256 _lpStakedInCurve = _curveGauge.balanceOf(address(this));\n        if (_lpStakedInCurve > 0) {\n            _curveGauge.withdraw(_lpStakedInCurve);\n        }\n    }\n\n    /// @dev Don't claiming rewards because `_claimRewards()` already does that\n    function _unstakeLp(uint256 _amount) internal override {\n        if (_amount > 0) {\n            if (!convexRewards().withdrawAndUnwrap(_amount, false)) revert UnstakeFromConvexFailed();\n        }\n    }\n}\n"
    },
    "contracts/strategies/curve/Curve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {CurveBase} from \"./CurveBase.sol\";\n\n/// @title This strategy will deposit collateral token in a Curve Pool and earn interest.\n// solhint-disable no-empty-blocks\ncontract Curve is CurveBase {\n    function initialize(CurveInitParams memory params_) external initializer {\n        __CurveBase_init(params_);\n    }\n}\n"
    },
    "contracts/strategies/curve/CurveBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IMasterOracle} from \"../../interfaces/one-oracle/IMasterOracle.sol\";\nimport {IAddressProvider} from \"../../interfaces/curve/IAddressProvider.sol\";\nimport {IDepositAndStake, IWithdraw} from \"../../interfaces/curve/ICurve.sol\";\nimport {ILiquidityGaugeV2} from \"../../interfaces/curve/ILiquidityGauge.sol\";\nimport {ILiquidityGaugeFactory} from \"../../interfaces/curve/ILiquidityGaugeFactory.sol\";\nimport {IMetaRegistry} from \"../../interfaces/curve/IMetaRegistry.sol\";\nimport {ITokenMinter} from \"../../interfaces/curve/ITokenMinter.sol\";\n\n/// @title Base contract for Curve-related strategies\nabstract contract CurveBase is Strategy {\n    using SafeERC20 for IERC20;\n\n    error CurveGaugeIsNull();\n    error CurveLpIsNull();\n    error CurvePoolZapIsNull();\n    error InvalidCollateral();\n    error InvalidSlippage();\n    error MaxFourCoinsAreAllowed();\n    error NotAllowedToSendEther();\n    error OnlyOneEthAllowedInUnderlying();\n    error SlippageTooHigh();\n\n    event SlippageUpdated(uint256 oldSlippage, uint256 newSlippage);\n    event MasterOracleUpdated(IMasterOracle oldMasterOracle, IMasterOracle newMasterOracle);\n\n    ITokenMinter public constant CRV_MINTER = ITokenMinter(0xd061D61a4d941c39E5453435B6345Dc261C2fcE0); // This contract only exists on mainnet\n    ILiquidityGaugeFactory public constant GAUGE_FACTORY =\n        ILiquidityGaugeFactory(0xabC000d88f23Bb45525E447528DBF656A9D55bf5); // Act as CRV_MINTER on side chains\n    IAddressProvider public constant ADDRESS_PROVIDER = IAddressProvider(0x5ffe7FB82894076ECB99A30D6A32e969e6e35E98); // Same address to all chains\n    uint256 private constant META_REGISTRY_ADDRESS_ID = 7;\n    uint256 private constant MAX_BPS = 10_000;\n\n    // Initialize params. Using this struct to mitigate stack too deep error.\n    // It is being used during initialize only.\n    struct CurveInitParams {\n        address pool;\n        address swapper;\n        address curvePool;\n        address curvePoolZap;\n        address depositAndStake;\n        bool useDynamicArray;\n        uint256 slippage;\n        address weth;\n        address masterOracle;\n        string name;\n    }\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.CurveBase\n    struct CurveBaseStorage {\n        address _curvePool;\n        IERC20 _curveLp;\n        ILiquidityGaugeV2 _curveGauge;\n        address _curvePoolZap;\n        address _depositAndStake;\n        IWETH _weth;\n        IMasterOracle _masterOracle;\n        address _depositContract;\n        address _curvePoolForDeposit;\n        uint256 _slippage;\n        int128 _collateralIdx;\n        address[] _underlyingTokens;\n        bool _useDynamicArray;\n        bool _useUnderlying;\n    }\n\n    bytes32 private constant CurveBaseStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.CurveBase\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getCurveBaseStorage() internal pure returns (CurveBaseStorage storage $) {\n        bytes32 _location = CurveBaseStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function __CurveBase_init(CurveInitParams memory params_) internal initializer {\n        // init require non-zero value for receiptToken hence setting it to 0x1.\n        // receiptToken is overridden in this contract to return curveLp address as receiptToken\n        __Strategy_init(params_.pool, params_.swapper, address(0x1), params_.name);\n\n        if (\n            params_.curvePool == address(0) ||\n            params_.depositAndStake == address(0) ||\n            params_.weth == address(0) ||\n            params_.masterOracle == address(0)\n        ) revert AddressIsNull();\n\n        IMetaRegistry _registry = IMetaRegistry(ADDRESS_PROVIDER.get_address(META_REGISTRY_ADDRESS_ID));\n\n        address _curveLp = _registry.get_lp_token(params_.curvePool);\n        if (_curveLp == address(0)) revert CurveLpIsNull();\n\n        address _curveGauge = _registry.get_gauge(params_.curvePool);\n        if (_curveGauge == address(0)) revert CurveGaugeIsNull();\n\n        CurveBaseStorage storage $ = _getCurveBaseStorage();\n        bool _isLendingTokenPool;\n        bool _isMetaPool;\n        ($._underlyingTokens, $._collateralIdx, _isMetaPool, _isLendingTokenPool) = _getCurvePoolInfo(\n            _registry,\n            params_.curvePool,\n            params_.weth\n        );\n        $._curvePool = params_.curvePool;\n        $._curveLp = IERC20(_curveLp);\n        $._curveGauge = ILiquidityGaugeV2(_curveGauge);\n        $._curvePoolZap = params_.curvePoolZap;\n        $._depositAndStake = params_.depositAndStake;\n        $._weth = IWETH(params_.weth);\n        $._masterOracle = IMasterOracle(params_.masterOracle);\n        $._slippage = params_.slippage;\n        $._useDynamicArray = params_.useDynamicArray;\n\n        if (_isMetaPool) {\n            if (params_.curvePoolZap == address(0)) revert CurvePoolZapIsNull();\n            $._depositContract = params_.curvePoolZap;\n            $._curvePoolForDeposit = params_.curvePool;\n        } else {\n            $._depositContract = params_.curvePool;\n        }\n\n        if (_isLendingTokenPool && params_.curvePoolZap != address(0)) {\n            $._depositContract = params_.curvePoolZap;\n            // useUnderlying is false in this case and false is default to no need to set.\n        } else {\n            // otherwise set useUnderlying\n            $._useUnderlying = _isLendingTokenPool;\n        }\n    }\n\n    receive() external payable {\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n        address _curvePool = s._curvePool;\n        IWETH _weth = s._weth;\n        if (msg.sender != _curvePool && msg.sender != address(_weth)) revert NotAllowedToSendEther();\n        if (msg.sender == _curvePool) {\n            _weth.deposit{value: address(this).balance}();\n        }\n    }\n\n    function curvePool() public view returns (address) {\n        return _getCurveBaseStorage()._curvePool;\n    }\n\n    function curveLp() public view returns (IERC20) {\n        return _getCurveBaseStorage()._curveLp;\n    }\n\n    function curveGauge() public view returns (ILiquidityGaugeV2) {\n        return _getCurveBaseStorage()._curveGauge;\n    }\n\n    function curvePoolZap() public view returns (address) {\n        return _getCurveBaseStorage()._curvePoolZap;\n    }\n\n    function depositAndStake() public view returns (address) {\n        return _getCurveBaseStorage()._depositAndStake;\n    }\n\n    function getUnderlyingTokens() public view returns (address[] memory) {\n        return _getCurveBaseStorage()._underlyingTokens;\n    }\n\n    // Gets LP value not staked in gauge\n    function lpBalanceHere() public view returns (uint256 _lpHere) {\n        _lpHere = curveLp().balanceOf(address(this));\n    }\n\n    function lpBalanceHereAndStaked() public view returns (uint256 _lpHereAndStaked) {\n        _lpHereAndStaked = curveLp().balanceOf(address(this)) + lpBalanceStaked();\n    }\n\n    function lpBalanceStaked() public view virtual returns (uint256 _lpStaked) {\n        _lpStaked = curveGauge().balanceOf(address(this));\n    }\n\n    function masterOracle() public view returns (IMasterOracle) {\n        return _getCurveBaseStorage()._masterOracle;\n    }\n\n    function receiptToken() public view override returns (address) {\n        return address(curveLp());\n    }\n\n    function slippage() public view returns (uint256) {\n        return _getCurveBaseStorage()._slippage;\n    }\n\n    /// @notice Returns collateral balance + collateral deposited to curve\n    function tvl() external view override returns (uint256) {\n        return collateralToken().balanceOf(address(this)) + _quoteLpToCollateral(lpBalanceHereAndStaked());\n    }\n\n    function _approveToken(uint256 amount_) internal virtual override {\n        super._approveToken(amount_);\n\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n        if (s._curvePoolZap != address(0)) {\n            // It is needed for withdrawal\n            s._curveLp.forceApprove(s._curvePoolZap, amount_);\n        }\n\n        address _swapper = address(swapper());\n        address[] memory _underlyingTokens = s._underlyingTokens;\n        uint256 _nCoins = _underlyingTokens.length;\n        for (uint256 i; i < _nCoins; i++) {\n            address _underlyingToken = _underlyingTokens[i];\n            IERC20(_underlyingToken).forceApprove(_swapper, amount_);\n            IERC20(_underlyingToken).forceApprove(s._depositAndStake, amount_);\n        }\n\n        // Gauge needs to be approved for stake via depositAndStake contract. Some Gauge doesn't support this method\n        try ILiquidityGaugeV2(s._curveGauge).set_approve_deposit(s._depositAndStake, true) {} catch {}\n    }\n\n    function _claimRewards() internal override {\n        ILiquidityGaugeV2 _curveGauge = curveGauge();\n        if (block.chainid == 1) {\n            CRV_MINTER.mint(address(_curveGauge));\n        } else if (GAUGE_FACTORY.is_valid_gauge(address(_curveGauge))) {\n            // On side chain gauge factory can mint CRV reward but only for valid gauge.\n            GAUGE_FACTORY.mint(address(_curveGauge));\n        }\n        // solhint-disable-next-line no-empty-blocks\n        try _curveGauge.claim_rewards() {} catch {\n            // This call may fail in some scenarios\n            // e.g. 3Crv gauge doesn't have such function\n        }\n    }\n\n    // @dev Convex strategy will have to override this to unstake from gauge and stake in Booster\n    function _deposit() internal virtual {\n        _depositAndStakeToCurve();\n    }\n\n    function _depositAndStakeToCurve() internal {\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n        uint256[] memory _depositAmounts;\n        uint256 _minMintAmount;\n        uint256 _ethValue;\n        {\n            bool _isAmountZero;\n            (_depositAmounts, _minMintAmount, _ethValue, _isAmountZero) = _getDepositData(s);\n            if (_isAmountZero) return;\n        }\n\n        IDepositAndStake(s._depositAndStake).deposit_and_stake{value: _ethValue}(\n            s._depositContract,\n            address(s._curveLp),\n            address(s._curveGauge),\n            s._underlyingTokens.length,\n            s._underlyingTokens,\n            _depositAmounts,\n            _minMintAmount,\n            s._useUnderlying,\n            s._useDynamicArray,\n            s._curvePoolForDeposit\n        );\n    }\n\n    function _getCurvePoolInfo(\n        IMetaRegistry registry_,\n        address curvePool_,\n        address _weth\n    )\n        internal\n        view\n        returns (address[] memory _underlyingTokens, int128 _collateralIdx, bool _isMetaPool, bool _isLendingTokenPool)\n    {\n        /// Note: collateralToken() is defined in parent contract and must be initialized before reading it.\n        address _collateralToken = address(collateralToken());\n        // This is the actual number of underlying tokens in Curve pool\n        uint256 _nCoins = registry_.get_n_underlying_coins(curvePool_);\n        if (_nCoins > 4) revert MaxFourCoinsAreAllowed();\n        // We will track underlyingTokens array. It has length equal to _nCoins.\n        _underlyingTokens = new address[](_nCoins);\n        // get_underlying_coins always returns array of 8 length\n        address[8] memory _underlyingCoins = registry_.get_underlying_coins(curvePool_);\n        uint256 _collateralPos = type(uint256).max;\n        for (uint256 i; i < _nCoins; i++) {\n            _underlyingTokens[i] = _underlyingCoins[i];\n            if (_underlyingCoins[i] == _collateralToken || (_underlyingCoins[i] == ETH && _collateralToken == _weth)) {\n                _collateralPos = i;\n            }\n        }\n        if (_collateralPos > _nCoins) revert InvalidCollateral();\n\n        _isMetaPool = registry_.is_meta(curvePool_);\n        // we know that collateral is in _underlyingCoins but if it is not in get_coins then it is lendingTokenPool\n        // A lendingToken pool is the one which hold lending(aToken, cToken) token as Curve collateral token.\n        if (!_isMetaPool && _underlyingCoins[_collateralPos] != registry_.get_coins(curvePool_)[_collateralPos]) {\n            _isLendingTokenPool = true;\n        }\n        _collateralIdx = int128(int256(_collateralPos));\n    }\n\n    function _getDepositData(CurveBaseStorage memory s) private returns (uint256[] memory, uint256, uint256, bool) {\n        uint256[] memory _depositAmounts = new uint256[](8);\n        uint256 _minMintAmount;\n        uint256 _ethValue;\n        bool _isAmountZero = true; // Assume deposit amount is zero\n\n        // Iterate through all underlying tokens.\n        // Check balance of underlyingToken to determine depositAmount\n        // Get quote of underlying token to collateral to calculate minimum out\n        uint256 _nCoins = s._underlyingTokens.length;\n        for (uint256 i; i < _nCoins; i++) {\n            address _underlyingToken = s._underlyingTokens[i];\n            // ETH can be found at max once in underlyingTokens.\n            if (_underlyingToken == ETH) {\n                if (_ethValue != 0) revert OnlyOneEthAllowedInUnderlying();\n                IWETH _weth = s._weth;\n                _depositAmounts[i] = _weth.balanceOf(address(this));\n                _weth.withdraw(_depositAmounts[i]);\n                _ethValue = _depositAmounts[i];\n                _minMintAmount += _getQuoteFromOracle(address(_weth), address(s._curveLp), _depositAmounts[i]);\n            } else {\n                _depositAmounts[i] = IERC20(_underlyingToken).balanceOf(address(this));\n                _minMintAmount += _getQuoteFromOracle(_underlyingToken, address(s._curveLp), _depositAmounts[i]);\n            }\n            // If deposit amount for any underlyingToken is non zero then set the zero flag to false\n            if (_depositAmounts[i] > 0) _isAmountZero = false;\n        }\n        _minMintAmount = (_minMintAmount * (MAX_BPS - s._slippage)) / MAX_BPS;\n        return (_depositAmounts, _minMintAmount, _ethValue, _isAmountZero);\n    }\n\n    function _getQuoteFromOracle(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) private view returns (uint256) {\n        if (tokenIn_ == tokenOut_) {\n            return amountIn_;\n        } else {\n            return masterOracle().quote(tokenIn_, tokenOut_, amountIn_);\n        }\n    }\n\n    function _quoteForWithdrawOneCoin(uint256 lpAmountIn_) private view returns (uint256 _amountOut) {\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n\n        if (s._curvePoolZap != address(0)) {\n            _amountOut = IWithdraw(s._curvePoolZap).calc_withdraw_one_coin(s._curvePool, lpAmountIn_, s._collateralIdx);\n        } else {\n            _amountOut = IWithdraw(s._curvePool).calc_withdraw_one_coin(lpAmountIn_, s._collateralIdx);\n        }\n    }\n\n    function _quoteLpToCollateral(uint256 lpAmountIn_) private view returns (uint256 _amountOut) {\n        if (lpAmountIn_ == 0) {\n            return 0;\n        }\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n\n        if (s._curvePoolZap != address(0)) {\n            _amountOut = IWithdraw(s._curvePoolZap).calc_withdraw_one_coin(s._curvePool, lpAmountIn_, s._collateralIdx);\n        } else {\n            _amountOut = IWithdraw(s._curvePool).calc_withdraw_one_coin(lpAmountIn_, s._collateralIdx);\n        }\n    }\n\n    function _quoteWithSlippageCheck(uint256 lpAmountIn_) private view returns (uint256 _amountOut) {\n        uint256 _oracleAmount = _getQuoteFromOracle(address(curveLp()), address(collateralToken()), lpAmountIn_);\n        _amountOut = _quoteLpToCollateral(lpAmountIn_);\n        if (_amountOut < (_oracleAmount * (MAX_BPS - slippage())) / MAX_BPS) revert SlippageTooHigh();\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _lpHere = lpBalanceHere();\n        uint256 _totalLp = _lpHere + lpBalanceStaked();\n        uint256 _collateralInCurve = _quoteWithSlippageCheck(_totalLp);\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _collateralHere + _collateralInCurve;\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            uint256 _totalAmountToWithdraw = _profitAndExcessDebt - _collateralHere;\n            uint256 _lpToBurn = Math.min((_totalAmountToWithdraw * _totalLp) / _collateralInCurve, _totalLp);\n            if (_lpToBurn > 0) {\n                _withdrawHere(_lpHere, _lpToBurn);\n                _collateralHere = _collateralToken.balanceOf(address(this));\n            }\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n\n        _pool.reportEarning(_profit, _loss, _payback);\n        _deposit();\n    }\n\n    function _unstakeLp(uint256 amount_) internal virtual {\n        if (amount_ > 0) {\n            curveGauge().withdraw(amount_);\n        }\n    }\n\n    /// @dev It is okay to set 0 as _minOut as there is another check in place in calling function.\n    function _withdrawAllCoinsFromCurve(uint256 nCoins_, uint256 lpToBurn_) private {\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n        address _curvePool = s._curvePool;\n        address _curvePoolZap = s._curvePoolZap;\n        if (s._useDynamicArray) {\n            IWithdraw(_curvePool).remove_liquidity(lpToBurn_, new uint256[](nCoins_));\n        } else if (nCoins_ == 2) {\n            uint256[2] memory _minOut;\n            if (_curvePoolZap != address(0)) {\n                IWithdraw(_curvePoolZap).remove_liquidity(lpToBurn_, _minOut);\n            } else {\n                IWithdraw(_curvePool).remove_liquidity(lpToBurn_, _minOut);\n            }\n        } else if (nCoins_ == 3) {\n            uint256[3] memory _minOut;\n\n            if (_curvePoolZap != address(0)) {\n                IWithdraw(_curvePoolZap).remove_liquidity(_curvePool, lpToBurn_, _minOut);\n            } else {\n                IWithdraw(_curvePool).remove_liquidity(lpToBurn_, _minOut);\n            }\n        } else if (nCoins_ == 4) {\n            uint256[4] memory _minOut;\n            if (_curvePoolZap != address(0)) {\n                IWithdraw(_curvePoolZap).remove_liquidity(_curvePool, lpToBurn_, _minOut);\n            } else {\n                IWithdraw(_curvePool).remove_liquidity(lpToBurn_, _minOut);\n            }\n        }\n    }\n\n    function _withdrawHere(uint256 coinAmountOut_) internal override {\n        uint256 _lpHere = lpBalanceHere();\n        uint256 _totalLp = _lpHere + lpBalanceStaked();\n        uint256 _totalCollateral = _quoteLpToCollateral(_totalLp);\n        uint256 _lpToBurn = Math.min((coinAmountOut_ * _totalLp) / _totalCollateral, _totalLp);\n        if (_lpToBurn == 0) return;\n\n        _withdrawHere(_lpHere, _lpToBurn);\n    }\n\n    function _withdrawHere(uint256 lpHere_, uint256 lpToBurn_) internal {\n        if (lpToBurn_ > lpHere_) {\n            _unstakeLp(lpToBurn_ - lpHere_);\n        }\n\n        address _collateralToken = address(collateralToken());\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n        // We can check amountOut_ against collateral received but it will serve as extra security measure\n        uint256 _oracleQuote = _getQuoteFromOracle(address(s._curveLp), _collateralToken, lpToBurn_);\n        uint256 _minAmountOut = (_oracleQuote * (MAX_BPS - s._slippage)) / MAX_BPS;\n\n        uint256 _collateralOut = _withdrawOneCoinFromCurve(s, lpToBurn_);\n\n        if (_collateralOut < _minAmountOut) revert SlippageTooHigh();\n    }\n\n    function _withdrawOneCoinFromCurve(CurveBaseStorage memory s, uint256 lpToBurn_) internal returns (uint256) {\n        // Withdraw is protected by collateral balance check at the end, so it if fine to use 1 as min out.\n        uint256 _minOut = 1;\n        int128 _i = s._collateralIdx;\n        if (s._curvePoolZap != address(0)) {\n            return IWithdraw(s._curvePoolZap).remove_liquidity_one_coin(s._curvePool, lpToBurn_, _i, _minOut);\n        } else if (s._useUnderlying) {\n            return IWithdraw(s._curvePool).remove_liquidity_one_coin(lpToBurn_, _i, _minOut, true);\n        } else {\n            return IWithdraw(s._curvePool).remove_liquidity_one_coin(lpToBurn_, _i, _minOut);\n        }\n    }\n\n    /************************************************************************************************\n     *                          Governor/admin/keeper function                                      *\n     ***********************************************************************************************/\n    function updateSlippage(uint256 newSlippage_) external onlyGovernor {\n        if (newSlippage_ >= MAX_BPS) revert InvalidSlippage();\n\n        CurveBaseStorage storage $ = _getCurveBaseStorage();\n        emit SlippageUpdated($._slippage, newSlippage_);\n        $._slippage = newSlippage_;\n    }\n\n    function updateMasterOracle(IMasterOracle newMasterOracle_) external onlyGovernor {\n        if (address(newMasterOracle_) == address(0)) revert AddressIsNull();\n\n        CurveBaseStorage storage $ = _getCurveBaseStorage();\n        emit MasterOracleUpdated($._masterOracle, newMasterOracle_);\n        $._masterOracle = newMasterOracle_;\n    }\n\n    /// @notice onlyKeeper:This function will withdraw all underlying tokens from Curve as oppose to regular\n    /// collateral withdrawal. Caller should call this via callStatic to get values for minAmountsOut.\n    /// Note: In order to get collaterals, keeper will have swap underlying tokens to collateral.\n    function withdrawAllCoins(uint256 minAmountOut_) external onlyKeeper returns (uint256 _amountOut) {\n        uint256 _lpHere = lpBalanceHere();\n        uint256 _lpStaked = lpBalanceStaked();\n        uint256 _totalLp = _lpHere + lpBalanceStaked();\n\n        if (_lpStaked > 0) {\n            _unstakeLp(_lpStaked);\n        }\n\n        address _collateralToken = address(collateralToken());\n        uint256 _collateralBefore = IERC20(_collateralToken).balanceOf(address(this));\n        CurveBaseStorage memory s = _getCurveBaseStorage();\n\n        address[] memory _underlyingTokens = s._underlyingTokens;\n        uint256 _nCoins = _underlyingTokens.length;\n\n        _withdrawAllCoinsFromCurve(_nCoins, _totalLp);\n\n        for (uint256 i; i < _nCoins; i++) {\n            address _underlyingToken = _underlyingTokens[i];\n            if (_underlyingToken == _collateralToken) {\n                continue;\n            }\n            uint256 _underlyingBalance = IERC20(_underlyingToken).balanceOf(address(this));\n            if (_underlyingBalance > 0) {\n                _swapExactInput(_underlyingToken, _collateralToken, _underlyingBalance);\n            }\n        }\n        _amountOut = IERC20(_collateralToken).balanceOf(address(this)) - _collateralBefore;\n        if (_amountOut < minAmountOut_) revert SlippageTooHigh();\n    }\n}\n"
    },
    "contracts/strategies/euler/EulerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {IEulerV2} from \"../../interfaces/euler/IEulerV2.sol\";\n\n/**\n * @title Euler V2 strategy.\n * @notice This strategy will supply collateral in Euler Vault. Vault is ERC4626 implementation.\n */\ncontract EulerV2 is Strategy {\n    using SafeERC20 for IERC20;\n\n    error InvalidVault();\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) external initializer {\n        if (receiptToken_ == address(0)) revert AddressIsNull();\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n        if (IEulerV2(receiptToken_).asset() != address(IVesperPool(pool_).token())) revert InvalidVault();\n    }\n\n    function euler() public view returns (IEulerV2) {\n        return IEulerV2(receiptToken());\n    }\n\n    function tvl() external view override returns (uint256) {\n        return _getCollateralInProtocol() + collateralToken().balanceOf(address(this));\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(euler()), amount_);\n    }\n\n    /**\n     * @dev Deposit collateral in Euler Vault.\n     */\n    function _deposit(uint256 amount_) internal {\n        IEulerV2 _euler = euler();\n        if (_euler.convertToShares(amount_) > 0) {\n            _euler.deposit(amount_, address(this));\n        }\n    }\n\n    /// Get total collateral deposited in protocol\n    function _getCollateralInProtocol() internal view returns (uint256) {\n        IEulerV2 _euler = euler();\n        return _euler.convertToAssets(_euler.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Generate report for pools accounting and also send profit and any payback to pool.\n     */\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _collateralHere + _getCollateralInProtocol();\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        _pool.reportEarning(_profit, _loss, _payback);\n        // After reportEarning strategy may get more collateral from pool. Deposit those in Euler Vault.\n        _deposit(_collateralToken.balanceOf(address(this)));\n    }\n\n    /// @dev Withdraw collateral here.\n    function _withdrawHere(uint256 amount_) internal override {\n        IEulerV2 _euler = euler();\n        // Get minimum of amount_ and _available collateral\n        uint256 _withdrawAmount = Math.min(amount_, _euler.maxWithdraw(address(this)));\n        _euler.withdraw(_withdrawAmount, address(this), address(this));\n    }\n}\n"
    },
    "contracts/strategies/extra-finance/ExtraFinance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport \"../Strategy.sol\";\nimport \"../../interfaces/extra-finance/ILendingPool.sol\";\nimport \"../../interfaces/extra-finance/IEToken.sol\";\nimport \"../../interfaces/extra-finance/IStakingRewards.sol\";\n\n/// @title This strategy will deposit collateral token in Extra Finance and earn interest.\ncontract ExtraFinance is Strategy {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IEToken;\n\n    error InvalidReserve();\n    error InvalidLendingPool();\n    error SlippageTooHigh();\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.ExtraFinance\n    struct ExtraFinanceStorage {\n        ILendingPool _lendingPool;\n        IStakingRewards _staking;\n        IEToken _eToken;\n        uint256 _reserveId;\n    }\n\n    bytes32 private constant ExtraFinanceStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.ExtraFinance\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getExtraFinanceStorage() internal pure returns (ExtraFinanceStorage storage $) {\n        bytes32 _location = ExtraFinanceStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        ILendingPool lendingPool_,\n        uint256 reserveId_,\n        string memory name_\n    ) external initializer {\n        // init require non-zero value for receiptToken hence setting it to 0x1.\n        // receiptToken is overridden in this contract to return eToken address\n        __Strategy_init(pool_, swapper_, address(0x1), name_);\n\n        if (address(lendingPool_) == address(0)) revert AddressIsNull();\n        ExtraFinanceStorage storage $ = _getExtraFinanceStorage();\n        $._lendingPool = lendingPool_;\n\n        _setReserve(lendingPool_, reserveId_);\n    }\n\n    function eToken() public view returns (IEToken) {\n        return _getExtraFinanceStorage()._eToken;\n    }\n\n    /// @dev override receiptToken as eToken can be updated via migrateReserve function\n    function receiptToken() public view override returns (address) {\n        return address(eToken());\n    }\n\n    function lendingPool() public view returns (ILendingPool) {\n        return _getExtraFinanceStorage()._lendingPool;\n    }\n\n    function reserveId() public view returns (uint256) {\n        return _getExtraFinanceStorage()._reserveId;\n    }\n\n    function staking() public view returns (IStakingRewards) {\n        return _getExtraFinanceStorage()._staking;\n    }\n\n    /// @inheritdoc Strategy\n    function tvl() external view override returns (uint256) {\n        return collateralToken().balanceOf(address(this)) + _invested();\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal override {\n        ExtraFinanceStorage storage $ = _getExtraFinanceStorage();\n        address _lendingPool = address($._lendingPool);\n        IERC20 _eToken = $._eToken;\n        address _staking = address($._staking);\n\n        IERC20 _collateralToken = collateralToken();\n        _collateralToken.forceApprove(pool(), amount_);\n        _collateralToken.forceApprove(_lendingPool, amount_);\n\n        _eToken.forceApprove(_staking, amount_);\n        _eToken.forceApprove(_lendingPool, amount_);\n    }\n\n    /// @inheritdoc Strategy\n    function _claimRewards() internal override {\n        staking().claim();\n    }\n\n    /// @dev Convert eToken amount to collateral amount\n    function _convertToCollateral(uint256 eTokenAmount_) private view returns (uint256 _collateralAmount) {\n        return (eTokenAmount_ * lendingPool().exchangeRateOfReserve(reserveId())) / 1e18;\n    }\n\n    /// @dev Convert collateral amount to eToken amount\n    function _convertToReceiptToken(uint256 collateralAmount_) private view returns (uint256 _eTokenAmount) {\n        return (collateralAmount_ * 1e18) / lendingPool().exchangeRateOfReserve(reserveId());\n    }\n\n    /// @dev Deposit collateral and stake the received eTokens\n    function _deposit(uint256 amount_) internal {\n        if (amount_ > 0) {\n            lendingPool().deposit(reserveId(), amount_, address(this), 0);\n            uint256 _eTokenBalance = eToken().balanceOf(address(this));\n            if (_eTokenBalance > 0) {\n                staking().stake(_eTokenBalance, address(this)); // stake all\n            }\n        }\n    }\n\n    /// @dev Total collateral amount allocated\n    function _invested() private view returns (uint256) {\n        return _convertToCollateral(eToken().balanceOf(address(this)) + staking().balanceOf(address(this)));\n    }\n\n    /// @dev Generate report for pools accounting and also send profit and any payback to pool.\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _collateralHere + _invested();\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n\n        _pool.reportEarning(_profit, _loss, _payback);\n\n        // After reportEarning strategy may get more collateral from pool. Deposit those in ExtraFinance.\n        _deposit(_collateralToken.balanceOf(address(this)));\n    }\n\n    /// @dev set reserve params of protocol\n    function _setReserve(ILendingPool lendingPool_, uint256 reserveId_) private {\n        if (lendingPool_.getUnderlyingTokenAddress(reserveId_) != address(collateralToken())) revert InvalidReserve();\n\n        IEToken _eToken = IEToken(lendingPool_.getETokenAddress(reserveId_));\n        if (address(_eToken) == address(0)) revert AddressIsNull();\n        if (_eToken.lendingPool() != address(lendingPool_)) revert InvalidLendingPool();\n\n        IStakingRewards _staking = IStakingRewards(lendingPool_.getStakingAddress(reserveId_));\n        if (address(_staking) == address(0)) revert AddressIsNull();\n\n        ExtraFinanceStorage storage $ = _getExtraFinanceStorage();\n        $._reserveId = reserveId_;\n        $._eToken = _eToken;\n        $._staking = _staking;\n    }\n\n    function _unstakeAll() private {\n        IStakingRewards _staking = staking();\n        uint256 _staked = _staking.balanceOf(address(this));\n        if (_staked > 0) {\n            _staking.withdraw(_staked, address(this));\n        }\n    }\n\n    /// @dev Withdraw collateral here. Do not transfer to pool\n    function _withdrawHere(uint256 collateralAmount_) internal override {\n        // Get minimum of requested amount and available collateral\n        collateralAmount_ = Math.min(\n            collateralAmount_,\n            Math.min(_invested(), collateralToken().balanceOf(address(eToken())))\n        );\n\n        uint256 _eTokenAmount = _convertToReceiptToken(collateralAmount_);\n        uint256 _eTokenBalance = eToken().balanceOf(address(this));\n\n        if (_eTokenAmount > _eTokenBalance) {\n            uint256 _unstakeAmount = _eTokenAmount - _eTokenBalance;\n            staking().withdraw(_unstakeAmount, address(this));\n            _eTokenBalance = eToken().balanceOf(address(this));\n        }\n\n        if (_eTokenAmount > 0) {\n            lendingPool().redeem(reserveId(), Math.min(_eTokenAmount, _eTokenBalance), address(this), false);\n        }\n    }\n\n    /************************************************************************************************\n     *                          Governor/admin/keeper function                                      *\n     ***********************************************************************************************/\n\n    /// @notice Migrate funds to another reserve that supports' the same collateral\n    function migrateReserve(uint256 newReserveId_) external onlyGovernor {\n        // 1. Claim rewards from current staking contract\n        IERC20 _collateralToken = collateralToken();\n        _claimRewards();\n\n        // 2. Withdraw all collateral\n        // Note: Do not use `_withdrawHere` in order to make it reverts if available liquidity isn't enough\n        _unstakeAll();\n        ILendingPool _lendingPool = lendingPool();\n        _lendingPool.redeem(reserveId(), eToken().balanceOf(address(this)), address(this), false);\n\n        // 3. Setup the new reserve\n        _setReserve(_lendingPool, newReserveId_);\n\n        // 4. Setup required approvals\n        _approveToken(MAX_UINT_VALUE);\n\n        // 5. Deposit all collateral to the new reserve\n        _deposit(_collateralToken.balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/strategies/fraxlend/Fraxlend.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {IFraxlendPair} from \"../../interfaces/fraxlend/IFraxlendPair.sol\";\n\n/// @title This strategy will deposit FRAX as collateral token in Fraxlend and earn interest.\nabstract contract Fraxlend is Strategy {\n    using SafeERC20 for IERC20;\n\n    error CollateralMismatch();\n\n    function __Fraxlend_init(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) internal initializer {\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n        if (IFraxlendPair(receiptToken_).asset() != address(collateralToken())) revert CollateralMismatch();\n    }\n\n    function fraxlendPair() public view returns (IFraxlendPair) {\n        return IFraxlendPair(receiptToken());\n    }\n\n    function tvl() external view override returns (uint256) {\n        return _balanceOfUnderlying() + collateralToken().balanceOf(address(this));\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal override {\n        IERC20 _collateralToken = collateralToken();\n        _collateralToken.forceApprove(pool(), amount_);\n        _collateralToken.forceApprove(address(fraxlendPair()), amount_);\n    }\n\n    function _balanceOfUnderlying() internal view virtual returns (uint256);\n\n    /**\n     * @notice Deposit collateral in Fraxlend.\n     */\n    function _deposit(uint256 amount_) internal {\n        if (amount_ > 0) {\n            fraxlendPair().deposit(amount_, address(this));\n        }\n    }\n\n    /**\n     * @dev Generate report for pools accounting and also send profit and any payback to pool.\n     */\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _collateralHere + _balanceOfUnderlying();\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n\n        _pool.reportEarning(_profit, _loss, _payback);\n        // After reportEarning strategy may get more collateral from pool. Deposit those in protocol.\n        _deposit(_collateralToken.balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/strategies/fraxlend/FraxlendV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IFraxlendPair} from \"../../interfaces/fraxlend/IFraxlendPair.sol\";\nimport {Fraxlend} from \"./Fraxlend.sol\";\n\n/// @title This strategy will deposit FRAX as collateral token in Fraxlend and earn interest.\ncontract FraxlendV1 is Fraxlend {\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) external initializer {\n        __Fraxlend_init(pool_, swapper_, receiptToken_, name_);\n    }\n\n    function _balanceOfUnderlying() internal view override returns (uint256) {\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        return _fraxlendPair.toAssetAmount(_fraxlendPair.balanceOf(address(this)), false);\n    }\n\n    function _withdrawHere(uint256 amount_) internal override {\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        // Check protocol has enough assets to entertain this withdraw amount_\n        uint256 _withdrawAmount = Math.min(\n            amount_,\n            (_fraxlendPair.totalAsset().amount - _fraxlendPair.totalBorrow().amount)\n        );\n\n        // Check we have enough LPs for this withdraw\n        uint256 _sharesToWithdraw = Math.min(\n            _fraxlendPair.toAssetShares(_withdrawAmount, false),\n            _fraxlendPair.balanceOf(address(this))\n        );\n\n        if (_sharesToWithdraw > 0) {\n            _fraxlendPair.redeem(_sharesToWithdraw, address(this), address(this));\n        }\n    }\n}\n"
    },
    "contracts/strategies/fraxlend/FraxlendV1Borrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {AggregatorV3Interface} from \"../../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {IFraxlendPair} from \"../../interfaces/fraxlend/IFraxlendPair.sol\";\n\n// solhint-disable var-name-mixedcase\n\n/// @title This strategy will deposit collateral token in Fraxlend and based on position it will\n/// borrow Frax.\nabstract contract FraxlendV1Borrow is Strategy {\n    using SafeERC20 for IERC20;\n\n    error CollateralMismatch();\n    error InvalidMaxBorrowLimit();\n    error InvalidSlippage();\n    error MaxShouldBeHigherThanMin();\n    error PriceError();\n\n    uint256 internal constant MAX_BPS = 10_000; //100%\n\n    event UpdatedBorrowLimit(\n        uint256 previousMinBorrowLimit,\n        uint256 newMinBorrowLimit,\n        uint256 previousMaxBorrowLimit,\n        uint256 newMaxBorrowLimit\n    );\n\n    event UpdatedSlippage(uint256 previousSlippage, uint256 newSlippage);\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.FraxlendV1Borrow\n    struct FraxlendV1BorrowStorage {\n        address _borrowToken;\n        uint256 _minBorrowLimit;\n        uint256 _maxBorrowLimit;\n        uint256 _slippage;\n        uint256 _exchangePrecision;\n        uint256 _ltvPrecision;\n        uint256 _maxLtv;\n    }\n\n    bytes32 private constant FraxlendV1BorrowStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.FraxlendV1Borrow\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getFraxlendV1BorrowStorage() internal pure returns (FraxlendV1BorrowStorage storage $) {\n        bytes32 _location = FraxlendV1BorrowStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function __FraxlendV1Borrow_init(\n        address pool_,\n        address swapper_,\n        address fraxlendPair_,\n        address borrowToken_,\n        string memory name_\n    ) internal initializer {\n        __Strategy_init(pool_, swapper_, fraxlendPair_, name_);\n\n        if (borrowToken_ == address(0)) revert AddressIsNull();\n\n        // This strategy will deposit collateral, collateralContract(), and borrow FRAX.\n        if (IFraxlendPair(fraxlendPair_).collateralContract() != address(collateralToken()))\n            revert CollateralMismatch();\n\n        FraxlendV1BorrowStorage storage $ = _getFraxlendV1BorrowStorage();\n        $._borrowToken = borrowToken_;\n        $._minBorrowLimit = 7_000; // 70% of actual collateral factor of protocol\n        $._maxBorrowLimit = 8_500; // 85% of actual collateral factor of protocol\n        $._slippage = 300; // 3%\n\n        (uint256 _LTV_PRECISION, , , , uint256 _EXCHANGE_PRECISION, , , ) = IFraxlendPair(fraxlendPair_).getConstants();\n        $._ltvPrecision = _LTV_PRECISION;\n        $._exchangePrecision = _EXCHANGE_PRECISION;\n        $._maxLtv = fraxlendPair().maxLTV();\n    }\n\n    /// @notice Gets amount of borrowed token in strategy + borrowed tokens invested\n    function borrowBalance() external view returns (uint256) {\n        return IERC20(borrowToken()).balanceOf(address(this)) + _getInvestedBorrowTokens();\n    }\n\n    function borrowToken() public view returns (address) {\n        return _getFraxlendV1BorrowStorage()._borrowToken;\n    }\n\n    function fraxlendPair() public view returns (IFraxlendPair) {\n        return IFraxlendPair(receiptToken());\n    }\n\n    function isReservedToken(address token_) public view virtual override returns (bool) {\n        return super.isReservedToken(token_) || token_ == borrowToken();\n    }\n\n    function maxBorrowLimit() public view returns (uint256) {\n        return _getFraxlendV1BorrowStorage()._maxBorrowLimit;\n    }\n\n    function minBorrowLimit() public view returns (uint256) {\n        return _getFraxlendV1BorrowStorage()._minBorrowLimit;\n    }\n\n    function slippage() public view returns (uint256) {\n        return _getFraxlendV1BorrowStorage()._slippage;\n    }\n\n    /// @notice Returns total collateral locked in the strategy\n    function tvl() external view override returns (uint256) {\n        return fraxlendPair().userCollateralBalance(address(this)) + collateralToken().balanceOf(address(this));\n    }\n\n    /// @dev Hook that executes after borrowing tokens.\n    function _afterBorrow(uint256 amount_) internal virtual;\n\n    /// @dev Approve all required tokens\n    function _approveToken(uint256 amount_) internal virtual override {\n        super._approveToken(amount_);\n\n        address _swapper = address(swapper());\n        IERC20 _collateralToken = collateralToken();\n        IERC20 _borrowToken = IERC20(borrowToken());\n        address _fraxlendPair = address(fraxlendPair());\n\n        _collateralToken.forceApprove(_fraxlendPair, amount_);\n        _collateralToken.forceApprove(_swapper, amount_);\n        _borrowToken.forceApprove(_fraxlendPair, amount_);\n        _borrowToken.forceApprove(_swapper, amount_);\n    }\n\n    function _borrowedFromFraxlend() internal view returns (uint256) {\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        return _fraxlendPair.toBorrowAmount(_fraxlendPair.userBorrowShares(address(this)), true);\n    }\n\n    function _calculateBorrow(uint256 collateralAmount_, uint256 exchangeRate_) internal view returns (uint256) {\n        FraxlendV1BorrowStorage storage $ = _getFraxlendV1BorrowStorage();\n        return (collateralAmount_ * $._maxLtv * $._exchangePrecision) / ($._ltvPrecision * exchangeRate_);\n    }\n\n    /**\n     * @dev Calculate borrow and repay amount based on current collateral and new deposit/withdraw amount.\n     * @param depositAmount_ deposit amount\n     * @param withdrawAmount_ withdraw amount\n     * @return _borrowAmount borrow more amount\n     * @return _repayAmount repay amount to keep ltv within limits\n     */\n    function _calculateBorrowPosition(\n        uint256 depositAmount_,\n        uint256 withdrawAmount_\n    ) internal view returns (uint256 _borrowAmount, uint256 _repayAmount) {\n        require(depositAmount_ == 0 || withdrawAmount_ == 0, \"all-input-gt-zero\");\n        uint256 _borrowed = _borrowedFromFraxlend();\n        // If maximum borrow limit set to 0 then repay borrow\n        if (maxBorrowLimit() == 0) {\n            return (0, _borrowed);\n        }\n\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        uint256 _collateralSupplied = _fraxlendPair.userCollateralBalance(address(this));\n\n        // In case of withdraw, withdrawAmount_ may be greater than _collateralSupplied\n        uint256 _hypotheticalCollateral;\n        if (depositAmount_ > 0) {\n            _hypotheticalCollateral = _collateralSupplied + depositAmount_;\n        } else if (_collateralSupplied > withdrawAmount_) {\n            _hypotheticalCollateral = _collateralSupplied - withdrawAmount_;\n        }\n        // It is collateral:asset ratio. i.e. how much collateral to buy 1e18 asset\n        uint224 _exchangeRate = _fraxlendPair.exchangeRateInfo().exchangeRate;\n\n        // Max borrow limit in borrow token i.e. FRAX.\n        uint256 _maxBorrowPossible = _calculateBorrow(_hypotheticalCollateral, _exchangeRate);\n\n        // If maxBorrow is zero, we should repay total amount of borrow\n        if (_maxBorrowPossible == 0) {\n            return (0, _borrowed);\n        }\n\n        // Safe buffer to avoid liquidation due to price variations.\n        uint256 _borrowUpperBound = (_maxBorrowPossible * maxBorrowLimit()) / MAX_BPS;\n\n        // Borrow up to _borrowLowerBound and keep buffer of _borrowUpperBound - _borrowLowerBound for price variation\n        uint256 _borrowLowerBound = (_maxBorrowPossible * minBorrowLimit()) / MAX_BPS;\n\n        // If current borrow is greater than max borrow, then repay to achieve safe position else borrow more.\n        if (_borrowed > _borrowUpperBound) {\n            // If borrow > upperBound then it is greater than lowerBound too.\n            _repayAmount = _borrowed - _borrowLowerBound;\n        } else if (_borrowed < _borrowLowerBound) {\n            _borrowAmount = _borrowLowerBound - _borrowed;\n            uint256 _availableLiquidity = _getAvailableLiquidity();\n            if (_borrowAmount > _availableLiquidity) {\n                _borrowAmount = _availableLiquidity;\n            }\n        }\n    }\n\n    /// @dev Deposit collateral in protocol and adjust borrow position\n    function _deposit() internal {\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralBalance = _collateralToken.balanceOf(address(this));\n        (uint256 _borrowAmount, uint256 _repayAmount) = _calculateBorrowPosition(_collateralBalance, 0);\n        if (_repayAmount > 0) {\n            // Repay to maintain safe position\n            _repay(_repayAmount);\n            // Read collateral balance again as repay() may change balance\n            _collateralBalance = _collateralToken.balanceOf(address(this));\n            if (_collateralBalance > 0) {\n                fraxlendPair().addCollateral(_collateralBalance, address(this));\n            }\n        } else if (_borrowAmount > 0) {\n            // Happy path, mint more borrow more\n            // borrowAsset will deposit collateral and then borrow FRAX\n            fraxlendPair().borrowAsset(_borrowAmount, _collateralBalance, address(this));\n            // Deposit all borrow token, FRAX, we have.\n            _afterBorrow(IERC20(borrowToken()).balanceOf(address(this)));\n        }\n    }\n\n    function _getAvailableLiquidity() internal view returns (uint256) {\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        uint256 _totalAsset = _fraxlendPair.totalAsset().amount;\n        uint256 _totalBorrow = _fraxlendPair.totalBorrow().amount;\n        return _totalAsset > _totalBorrow ? _totalAsset - _totalBorrow : 0;\n    }\n\n    function _getInvestedBorrowTokens() internal view virtual returns (uint256);\n\n    /// @dev Get chainlink oracle from fraxlendPair contract\n    function _getOracle(address token_) internal view returns (address _oracle) {\n        if (token_ == borrowToken()) {\n            // Oracle multiply is configured for borrowToken aka asset.\n            // For FRAX it is set to null as price of FRAX is expected to be $1.\n            _oracle = fraxlendPair().oracleMultiply();\n        } else {\n            // Oracle divide is configured for collateral\n            _oracle = fraxlendPair().oracleDivide();\n        }\n    }\n\n    /// @dev Get Price from oracle. Price has 8 decimals.\n    function _getPrice(address token_) internal view returns (uint256 _price) {\n        address _oracle = _getOracle(token_);\n        if (_oracle == address(0)) {\n            _price = 1e8;\n        } else {\n            (, int256 _answer, , , ) = AggregatorV3Interface(_oracle).latestRoundData();\n            _price = uint256(_answer);\n            if (_price == 0) revert PriceError();\n        }\n    }\n\n    /**\n     * @dev Get quote for token price in terms of other token.\n     * @param tokenIn_ tokenIn\n     * @param tokenOut_ tokenOut\n     * @param amountIn_ amount of tokenIn_\n     * @return amountOut of tokenOut_ for amountIn_ of tokenIn_\n     */\n    function _quote(address tokenIn_, address tokenOut_, uint256 amountIn_) internal view returns (uint256) {\n        uint256 _tokenInPrice = _getPrice(tokenIn_);\n        uint256 _tokenOutPrice = _getPrice(tokenOut_);\n        return ((_tokenInPrice * amountIn_ * (10 ** IERC20Metadata(tokenOut_).decimals())) /\n            (10 ** IERC20Metadata(tokenIn_).decimals() * _tokenOutPrice));\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        // Accrue and update interest\n        _fraxlendPair.addInterest();\n\n        IERC20 _collateralToken = collateralToken();\n        IERC20 _borrowToken = IERC20(borrowToken());\n        {\n            uint256 _borrowed = _borrowedFromFraxlend();\n            uint256 _borrowTokensHere = _borrowToken.balanceOf(address(this));\n            uint256 _investedBorrowTokens = _getInvestedBorrowTokens();\n            uint256 _totalBorrowTokens = _borrowTokensHere + _investedBorrowTokens;\n\n            // _borrow increases every block. Convert collateral to borrowToken.\n            if (_borrowed > _totalBorrowTokens) {\n                _swapToBorrowToken(_borrowed - _totalBorrowTokens);\n            } else {\n                // When _investedBorrowTokens exceeds _borrowed from protocol\n                // then we have profit from investing borrow tokens. _borrowTokensHere is profit.\n                if (_investedBorrowTokens > _borrowed) {\n                    _withdrawBorrowTokens(_investedBorrowTokens - _borrowed);\n                    _borrowTokensHere = _borrowToken.balanceOf(address(this));\n                }\n                if (_borrowTokensHere > 0) {\n                    // Get quote for _amountIn of borrowToken to collateralToken\n                    uint256 _expectedAmountOut = _quote(\n                        address(_borrowToken),\n                        address(_collateralToken),\n                        _borrowTokensHere\n                    );\n                    uint256 _minAmountOut = (_expectedAmountOut * (MAX_BPS - slippage())) / MAX_BPS;\n                    swapper().swapExactInput(\n                        address(_borrowToken),\n                        address(_collateralToken),\n                        _borrowTokensHere,\n                        _minAmountOut,\n                        address(this)\n                    );\n                }\n            }\n        }\n\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _collateralInFraxlend = _fraxlendPair.userCollateralBalance(address(this));\n        uint256 _totalCollateral = _collateralInFraxlend + _collateralHere;\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_collateralHere < _profitAndExcessDebt) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Set actual payback first and then profit. Make sure _collateralHere >= _payback + profit.\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n\n        _pool.reportEarning(_profit, _loss, _payback);\n        _deposit();\n    }\n\n    /**\n     * @dev Repay borrow amount\n     * @param _repayAmount BorrowToken amount that we should repay to maintain safe position.\n     */\n    function _repay(uint256 _repayAmount) internal {\n        if (_repayAmount > 0) {\n            uint256 _totalBorrowTokens = IERC20(borrowToken()).balanceOf(address(this)) + _getInvestedBorrowTokens();\n            // Liability is more than what we have.\n            // To repay loan - convert all rewards to collateral, if asked, and redeem collateral(if needed).\n            // This scenario is rare and if system works okay it will/might happen during final repay only.\n            if (_repayAmount > _totalBorrowTokens) {\n                uint256 _borrowed = _borrowedFromFraxlend();\n                // For example this is final repay and 100 blocks has passed since last withdraw/rebalance,\n                // _borrowed is increasing due to interest. Now if _repayAmount > _borrowBalanceHere is true\n                // _borrowed > _borrowBalanceHere is also true.\n                // To maintain safe position we always try to keep _borrowed = _borrowBalanceHere\n\n                // Swap collateral to borrowToken to repay borrow and also maintain safe position\n                // Here borrowToken amount needed is (_borrowed - _borrowBalanceHere)\n                _swapToBorrowToken(_borrowed - _totalBorrowTokens);\n            }\n            _repayBorrowTokens(_repayAmount);\n        }\n    }\n\n    /// @dev Repay borrow tokens to Fraxlend. Withdraw borrowTokens from end protocol if applicable.\n    function _repayBorrowTokens(uint256 amount_) internal {\n        _withdrawBorrowTokens(amount_);\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        uint256 _fraxShare = _fraxlendPair.toBorrowShares(amount_, false);\n        _fraxlendPair.repayAsset(_fraxShare, address(this));\n    }\n\n    /**\n     * @dev Swap given token to borrowToken\n     * @param shortOnBorrow_ Expected output of this swap\n     */\n    function _swapToBorrowToken(uint256 shortOnBorrow_) internal {\n        IERC20 _collateralToken = collateralToken();\n        address _borrowToken = borrowToken();\n        // Looking for _amountIn using fixed output amount\n        uint256 _expectedAmountIn = _quote(address(_collateralToken), _borrowToken, shortOnBorrow_);\n        if (_expectedAmountIn > 0) {\n            uint256 _maxAmountIn = (_expectedAmountIn * (MAX_BPS + slippage())) / MAX_BPS;\n            uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n            // If we do not have enough _from token to get expected output, either get\n            // some _from token or adjust expected output.\n            if (_maxAmountIn > _collateralHere) {\n                // Redeem some collateral, so that we have enough collateral to get expected output\n                fraxlendPair().removeCollateral(_maxAmountIn - _collateralHere, address(this));\n            }\n            swapper().swapExactOutput(\n                address(_collateralToken),\n                _borrowToken,\n                shortOnBorrow_,\n                _maxAmountIn,\n                address(this)\n            );\n        }\n    }\n\n    function _withdrawHere(uint256 amount_) internal override {\n        IFraxlendPair _fraxlendPair = fraxlendPair();\n        // Accrue and update interest\n        _fraxlendPair.addInterest();\n        (, uint256 _repayAmount) = _calculateBorrowPosition(0, amount_);\n        _repay(_repayAmount);\n\n        // Get minimum of amount_ and collateral supplied and _available collateral in Fraxlend\n        uint256 _withdrawAmount = Math.min(\n            amount_,\n            Math.min(_fraxlendPair.userCollateralBalance(address(this)), _fraxlendPair.totalCollateral())\n        );\n        _fraxlendPair.removeCollateral(_withdrawAmount, address(this));\n    }\n\n    function _withdrawBorrowTokens(uint256 amount_) internal virtual;\n\n    /************************************************************************************************\n     *                          Governor/admin/keeper function                                      *\n     ***********************************************************************************************/\n    /**\n     * @notice Recover extra borrow tokens from strategy\n     * @dev If we get liquidation in protocol, we will have borrowToken sitting in strategy.\n     * This function allows to recover idle borrow token amount.\n     * @param _amountToRecover Amount of borrow token we want to recover in 1 call.\n     *      Set it 0 to recover all available borrow tokens\n     */\n    function recoverBorrowToken(uint256 _amountToRecover) external onlyKeeper {\n        IERC20 _collateralToken = collateralToken();\n        address _borrowToken = borrowToken();\n        uint256 _borrowBalanceHere = IERC20(_borrowToken).balanceOf(address(this));\n        uint256 _borrow = _borrowedFromFraxlend();\n\n        if (_borrowBalanceHere > _borrow) {\n            uint256 _extraBorrowBalance = _borrowBalanceHere - _borrow;\n            uint256 _recoveryAmount = (_amountToRecover > 0 && _extraBorrowBalance > _amountToRecover)\n                ? _amountToRecover\n                : _extraBorrowBalance;\n            // Do swap and transfer\n            uint256 _amountOut = _trySwapExactInput(_borrowToken, address(_collateralToken), _recoveryAmount);\n            if (_amountOut > 0) {\n                _collateralToken.safeTransfer(pool(), _amountOut);\n            }\n        }\n    }\n\n    /**\n     * @notice Repay all borrow amount and set min borrow limit to 0.\n     * @dev This action usually done when loss is detected in strategy.\n     * @dev 0 borrow limit make sure that any future rebalance do not borrow again.\n     */\n    function repayAll() external onlyKeeper {\n        // Accrue and update interest\n        fraxlendPair().addInterest();\n        _repay(_borrowedFromFraxlend());\n\n        FraxlendV1BorrowStorage storage $ = _getFraxlendV1BorrowStorage();\n        $._minBorrowLimit = 0;\n        $._maxBorrowLimit = 0;\n    }\n\n    /**\n     * @notice Update upper and lower borrow limit. Usually maxBorrowLimit < 100% of actual collateral factor of protocol.\n     * @dev It is possible to set 0 as _minBorrowLimit to not borrow anything\n     * @param minBorrowLimit_ It is % of actual collateral factor of protocol\n     * @param maxBorrowLimit_ It is % of actual collateral factor of protocol\n     */\n    function updateBorrowLimit(uint256 minBorrowLimit_, uint256 maxBorrowLimit_) external onlyGovernor {\n        if (maxBorrowLimit_ >= MAX_BPS) revert InvalidMaxBorrowLimit();\n\n        // set _maxBorrowLimit and _minBorrowLimit to zero to disable borrow;\n        if ((maxBorrowLimit_ != 0 || minBorrowLimit_ != 0) && maxBorrowLimit_ <= minBorrowLimit_)\n            revert MaxShouldBeHigherThanMin();\n\n        FraxlendV1BorrowStorage storage $ = _getFraxlendV1BorrowStorage();\n        emit UpdatedBorrowLimit($._minBorrowLimit, minBorrowLimit_, $._maxBorrowLimit, maxBorrowLimit_);\n        // To avoid liquidation due to price variations maxBorrowLimit is a collateral factor that is less than actual collateral factor of protocol\n        $._minBorrowLimit = minBorrowLimit_;\n        $._maxBorrowLimit = maxBorrowLimit_;\n    }\n\n    function updateSlippage(uint256 newSlippage_) external onlyGovernor {\n        if (newSlippage_ > MAX_BPS) revert InvalidSlippage();\n        FraxlendV1BorrowStorage storage $ = _getFraxlendV1BorrowStorage();\n        emit UpdatedSlippage($._slippage, newSlippage_);\n        $._slippage = newSlippage_;\n    }\n}\n"
    },
    "contracts/strategies/fraxlend/FraxlendV1VesperBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {FraxlendV1Borrow} from \"./FraxlendV1Borrow.sol\";\n\n/// @title Deposit Collateral in Fraxlend and generate yield by depositing borrowed token into the Vesper Pool.\ncontract FraxlendV1VesperBorrow is FraxlendV1Borrow {\n    using SafeERC20 for IERC20;\n\n    error InvalidGrowPool();\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.FraxlendV1VesperBorrow\n    struct FraxlendV1VesperBorrowStorage {\n        IVesperPool _vPool;\n    }\n\n    bytes32 private constant FraxlendV1VesperBorrowStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.FraxlendV1VesperBorrow\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getFraxlendV1VesperBorrowStorage() internal pure returns (FraxlendV1VesperBorrowStorage storage $) {\n        bytes32 _location = FraxlendV1VesperBorrowStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address fraxlendPair_,\n        address borrowToken_,\n        address vPool_,\n        string memory name_\n    ) external initializer {\n        __FraxlendV1Borrow_init(pool_, swapper_, fraxlendPair_, borrowToken_, name_);\n        if (address(IVesperPool(vPool_).token()) != borrowToken()) revert InvalidGrowPool();\n        _getFraxlendV1VesperBorrowStorage()._vPool = IVesperPool(vPool_);\n    }\n\n    function isReservedToken(address token_) public view override returns (bool) {\n        return super.isReservedToken(token_) || token_ == address(vPool());\n    }\n\n    /// @notice Destination Grow Pool for borrowed Token\n    function vPool() public view returns (IVesperPool) {\n        return _getFraxlendV1VesperBorrowStorage()._vPool;\n    }\n\n    /// @notice After borrowing borrow tokens, deposit tokens to Vesper Pool\n    function _afterBorrow(uint256 amount_) internal override {\n        vPool().deposit(amount_);\n    }\n\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        IVesperPool _vPool = vPool();\n        IERC20(borrowToken()).forceApprove(address(_vPool), amount_);\n    }\n\n    function _getInvestedBorrowTokens() internal view override returns (uint256) {\n        IVesperPool _vPool = vPool();\n        return (_vPool.pricePerShare() * _vPool.balanceOf(address(this))) / 1e18;\n    }\n\n    /// @notice Withdraw _shares proportional to collateral _amount from vPool\n    function _withdrawBorrowTokens(uint256 amount_) internal override {\n        IVesperPool _vPool = vPool();\n        uint256 _pricePerShare = _vPool.pricePerShare();\n        uint256 _shares = (amount_ * 1e18) / _pricePerShare;\n        _shares = amount_ > ((_shares * _pricePerShare) / 1e18) ? _shares + 1 : _shares;\n        _shares = Math.min(_shares, _vPool.balanceOf(address(this)));\n        if (_shares > 0) {\n            _vPool.withdraw(_shares);\n        }\n    }\n}\n"
    },
    "contracts/strategies/fraxlend/FraxlendV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IFraxlendPairV3} from \"../../interfaces/fraxlend/IFraxlendPairV3.sol\";\nimport {Fraxlend} from \"./Fraxlend.sol\";\n\n/// @title This strategy will deposit FRAX as collateral token in Fraxlend and earn interest.\ncontract FraxlendV3 is Fraxlend {\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) external initializer {\n        __Fraxlend_init(pool_, swapper_, receiptToken_, name_);\n    }\n\n    function _balanceOfUnderlying() internal view override returns (uint256) {\n        IFraxlendPairV3 _fraxlendPair = _fraxlendPairV3();\n        return _fraxlendPair.convertToAssets(_fraxlendPair.balanceOf(address(this)));\n    }\n\n    function _fraxlendPairV3() private view returns (IFraxlendPairV3) {\n        return IFraxlendPairV3(receiptToken());\n    }\n\n    function _withdrawHere(uint256 amount_) internal override {\n        IFraxlendPairV3 _fraxlendPair = _fraxlendPairV3();\n        // Check protocol has enough assets to entertain this withdraw amount_\n        uint256 _withdrawAmount = Math.min(amount_, _fraxlendPair.maxWithdraw(address(this)));\n        _fraxlendPair.withdraw(_withdrawAmount, address(this), address(this));\n    }\n}\n"
    },
    "contracts/strategies/morpho/MorphoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {IMetaMorpho} from \"../../interfaces/morpho/IMetaMorpho.sol\";\n\n/**\n * @title Morpho Vault (MetaMorpho) strategy.\n * @notice This strategy will supply collateral in Morpho Vault. Vault is ERC4626 implementation.\n * It may earn some rewards. Anyone can claim rewards on behalf of this address on Universal Reward Distributor(URD).\n */\ncontract MorphoVault is Strategy {\n    using SafeERC20 for IERC20;\n\n    error InvalidVault();\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) external initializer {\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n        if (IMetaMorpho(receiptToken_).asset() != address(IVesperPool(pool_).token())) revert InvalidVault();\n    }\n\n    function metaMorpho() public view returns (IMetaMorpho) {\n        return IMetaMorpho(receiptToken());\n    }\n\n    function tvl() external view override returns (uint256) {\n        return _getCollateralInProtocol() + collateralToken().balanceOf(address(this));\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(metaMorpho()), amount_);\n    }\n\n    /**\n     * @dev Deposit collateral in Morpho Vault.\n     */\n    function _deposit(uint256 amount_) internal {\n        if (amount_ > 0) {\n            metaMorpho().deposit(amount_, address(this));\n        }\n    }\n\n    /// Get total collateral deposited in protocol\n    function _getCollateralInProtocol() internal view returns (uint256) {\n        IMetaMorpho _metaMorpho = metaMorpho();\n        return _metaMorpho.convertToAssets(_metaMorpho.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Generate report for pools accounting and also send profit and any payback to pool.\n     */\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _collateralHere + _getCollateralInProtocol();\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        _pool.reportEarning(_profit, _loss, _payback);\n        // After reportEarning strategy may get more collateral from pool. Deposit those in Morpho Vault.\n        _deposit(_collateralToken.balanceOf(address(this)));\n    }\n\n    /// @dev Withdraw collateral here.\n    function _withdrawHere(uint256 _amount) internal override {\n        IMetaMorpho _metaMorpho = metaMorpho();\n        // Get minimum of _amount and _available collateral\n        uint256 _withdrawAmount = Math.min(_amount, _metaMorpho.maxWithdraw(address(this)));\n        _metaMorpho.withdraw(_withdrawAmount, address(this), address(this));\n    }\n}\n"
    },
    "contracts/strategies/sommelier/Sommelier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {ICellar} from \"../../interfaces/sommelier/ISommelier.sol\";\nimport {SommelierBase} from \"./SommelierBase.sol\";\n\n/// @dev This strategy will deposit collateral token in Sommelier and earn yield.\ncontract Sommelier is Strategy, SommelierBase {\n    using SafeERC20 for IERC20;\n\n    error InvalidReceiptToken();\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) external initializer {\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n        __Sommelier_init(receiptToken_);\n        if (ICellar(receiptToken_).asset() != address(IVesperPool(pool_).token())) revert InvalidReceiptToken();\n    }\n\n    function tvl() public view override returns (uint256) {\n        return _getAssetsInSommelier() + collateralToken().balanceOf(address(this));\n    }\n\n    /// @notice Large approval of token\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(cellar()), amount_);\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _getAssetsInSommelier() + _collateralHere;\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        _pool.reportEarning(_profit, _loss, _payback);\n\n        // strategy may get new fund. deposit to generate yield\n        _collateralHere = _collateralToken.balanceOf(address(this));\n        if (_collateralHere > 0) {\n            cellar().deposit(_collateralHere, address(this));\n        }\n    }\n\n    /// @dev Withdraw collateral here\n    function _withdrawHere(uint256 requireAmount_) internal override {\n        _withdrawFromSommelier(requireAmount_);\n    }\n}\n"
    },
    "contracts/strategies/sommelier/SommelierBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ICellar} from \"../../interfaces/sommelier/ISommelier.sol\";\n\n/// @dev This strategy will deposit collateral token in Sommelier and earn yield.\nabstract contract SommelierBase {\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.SommelierBase\n    struct SommelierBaseStorage {\n        ICellar _cellar;\n    }\n\n    bytes32 private constant SommelierBaseStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.SommelierBase\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getSommelierBaseStorage() internal pure returns (SommelierBaseStorage storage $) {\n        bytes32 _location = SommelierBaseStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function __Sommelier_init(address cellar_) internal {\n        _getSommelierBaseStorage()._cellar = ICellar(cellar_);\n    }\n\n    function cellar() public view returns (ICellar) {\n        return _getSommelierBaseStorage()._cellar;\n    }\n\n    /**\n     * @notice Time when withdraw and transfer will be unlocked.\n     */\n    function unlockTime() public view returns (uint256) {\n        ICellar _cellar = cellar();\n        return _cellar.userShareLockStartTime(address(this)) + _cellar.shareLockPeriod();\n    }\n\n    function _depositInSommelier(uint256 amount_) internal returns (uint256 shares_) {\n        ICellar _cellar = cellar();\n        if (_cellar.previewDeposit(amount_) != 0) {\n            shares_ = _cellar.deposit(amount_, address(this));\n        }\n    }\n\n    function _getAssetsInSommelier() internal view returns (uint256) {\n        ICellar _cellar = cellar();\n        return _cellar.convertToAssets(_cellar.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Withdraw from sommelier vault\n     * @param requireAmount_ equivalent value of the assets withdrawn, denominated in the cellar's asset\n     * @return shares_ amount of shares redeemed\n     */\n    function _withdrawFromSommelier(uint256 requireAmount_) internal returns (uint256 shares_) {\n        if (block.timestamp >= unlockTime()) {\n            ICellar _cellar = cellar();\n            // withdraw asking more than available liquidity will fail. To do safe withdraw, check\n            // requireAmount_ against available liquidity.\n            uint256 _withdrawable = Math.min(\n                requireAmount_,\n                Math.min(_getAssetsInSommelier(), _cellar.totalAssetsWithdrawable())\n            );\n            if (_withdrawable > 0) {\n                shares_ = _cellar.withdraw(_withdrawable, address(this), address(this));\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/stargate/v2/StargateV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../../Strategy.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {IStargatePoolV2 as IStargatePool} from \"../../../interfaces/stargate/v2/IStargatePoolV2.sol\";\nimport {IStargateStaking} from \"../../../interfaces/stargate/v2/IStargateStaking.sol\";\n\n/// @title This Strategy will deposit collateral token in a StargateV2 Pool to yearn yield.\n/// Stake LP token to accrue rewards.\ncontract StargateV2 is Strategy {\n    using SafeERC20 for IERC20;\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.StargateV2\n    struct StargateV2Storage {\n        IStargatePool _stargatePool;\n        IStargateStaking _stargateStaking;\n    }\n\n    bytes32 private constant StargateV2StorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.StargateV2\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getStargateV2Storage() internal pure returns (StargateV2Storage storage $) {\n        bytes32 _location = StargateV2StorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        IStargatePool stargatePool_,\n        IStargateStaking stargateStaking_,\n        string memory name_\n    ) public initializer {\n        if (address(stargatePool_) == address(0)) revert AddressIsNull();\n        if (address(stargateStaking_) == address(0)) revert AddressIsNull();\n\n        address _stargateLp = stargatePool_.lpToken();\n\n        __Strategy_init(pool_, swapper_, _stargateLp, name_);\n\n        StargateV2Storage storage $ = _getStargateV2Storage();\n\n        $._stargatePool = stargatePool_;\n        $._stargateStaking = stargateStaking_;\n    }\n\n    function lpAmountStaked() public view returns (uint256 _lpAmountStaked) {\n        _lpAmountStaked = stargateStaking().balanceOf(stargateLp(), address(this));\n    }\n\n    function stargateLp() public view returns (IERC20) {\n        return IERC20(receiptToken());\n    }\n\n    function stargatePool() public view returns (IStargatePool) {\n        return _getStargateV2Storage()._stargatePool;\n    }\n\n    function stargateStaking() public view returns (IStargateStaking) {\n        return _getStargateV2Storage()._stargateStaking;\n    }\n\n    function tvl() external view override returns (uint256) {\n        return _getCollateralInStargate() + collateralToken().balanceOf(address(this));\n    }\n\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(stargatePool()), amount_);\n        stargateLp().forceApprove(address(stargateStaking()), amount_);\n    }\n\n    /// @dev Claim rewards from Staking contract\n    function _claimRewards() internal override {\n        IERC20[] memory _lpTokens = new IERC20[](1);\n        _lpTokens[0] = stargateLp();\n        stargateStaking().claim(_lpTokens);\n    }\n\n    function _deposit(uint256 collateralAmount_) internal virtual {\n        if (collateralAmount_ > 0) {\n            stargatePool().deposit(address(this), collateralAmount_);\n        }\n    }\n\n    /// @dev Gets collateral balance deposited into Stargate pool. Collateral and LP are, usually, 1:1.\n    function _getCollateralInStargate() internal view returns (uint256 _collateralStaked) {\n        return lpAmountStaked() + stargateLp().balanceOf(address(this));\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _getCollateralInStargate() + _collateralHere;\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n\n        _pool.reportEarning(_profit, _loss, _payback);\n\n        // strategy may get new fund. Deposit and stake it to stargate\n        _deposit(_collateralToken.balanceOf(address(this)));\n        _stakeLp();\n    }\n\n    function _stakeLp() internal {\n        IERC20 _stargateLp = stargateLp();\n        uint256 _lpAmount = _stargateLp.balanceOf(address(this));\n        if (_lpAmount > 0) {\n            stargateStaking().deposit(_stargateLp, _lpAmount);\n        }\n    }\n\n    function _unstakeLp(uint256 lpRequired_) internal {\n        IERC20 _stargateLp = stargateLp();\n        uint256 _lpHere = _stargateLp.balanceOf(address(this));\n        if (lpRequired_ > _lpHere) {\n            uint256 lpToUnstake_ = lpRequired_ - _lpHere;\n            uint256 _lpAmountStaked = lpAmountStaked();\n            if (lpToUnstake_ > _lpAmountStaked) {\n                lpToUnstake_ = _lpAmountStaked;\n            }\n            stargateStaking().withdraw(_stargateLp, lpToUnstake_);\n        }\n    }\n\n    /// @dev Withdraw collateral here. amount_ is collateral amount.\n    /// @dev This method may withdraw less than requested amount. Caller may need to check balance before and after\n    function _withdrawHere(uint256 amount_) internal override {\n        // LP and collateral are 1:1\n        _unstakeLp(amount_);\n\n        IStargatePool _stargatePool = stargatePool();\n        // Minimum of amount_, available LP and available collateral in Stargate pool.\n        amount_ = Math.min(amount_, Math.min(stargateLp().balanceOf(address(this)), _stargatePool.poolBalance()));\n\n        if (amount_ > 0) {\n            _stargatePool.redeem(amount_, address(this));\n        }\n    }\n}\n"
    },
    "contracts/strategies/stargate/v2/StargateV2ETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../../Strategy.sol\";\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\nimport {IVesperPool} from \"../../../interfaces/vesper/IVesperPool.sol\";\nimport {IStargatePoolV2 as IStargatePool} from \"../../../interfaces/stargate/v2/IStargatePoolV2.sol\";\nimport {IStargateStaking} from \"../../../interfaces/stargate/v2/IStargateStaking.sol\";\nimport {StargateV2} from \"./StargateV2.sol\";\n\n/// @title This Strategy will deposit ETH in a Stargate V2 Pool\n/// Stake LP Token and accrue swap rewards\ncontract StargateV2ETH is StargateV2 {\n    using SafeERC20 for IWETH;\n\n    error InvalidStargateDecimals();\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.StargateV2.ETH\n    struct StargateV2ETHStorage {\n        IWETH _weth;\n        uint256 _convertRate; // The rate between local decimals and shared decimals.\n    }\n\n    bytes32 private constant StargateV2ETHStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.StargateV2.ETH\")) - 1)) &\n            ~bytes32(uint256(0xff));\n\n    function _getStargateV2ETHStorage() internal pure returns (StargateV2ETHStorage storage $) {\n        bytes32 _location = StargateV2ETHStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function StargateV2ETH_initialize(\n        address pool_,\n        address swapper_,\n        IStargatePool stargatePool_,\n        IStargateStaking stargateStaking_,\n        IWETH weth_,\n        string memory name_\n    ) external initializer {\n        super.initialize(pool_, swapper_, stargatePool_, stargateStaking_, name_);\n\n        if (address(weth_) == address(0)) revert AddressIsNull();\n\n        StargateV2ETHStorage storage $ = _getStargateV2ETHStorage();\n        $._weth = weth_;\n\n        uint8 _sharedDecimals = stargatePool().sharedDecimals();\n        uint8 _localDecimals = IERC20Metadata(address(stargateLp())).decimals();\n        if (_localDecimals <= _sharedDecimals) revert InvalidStargateDecimals();\n\n        $._convertRate = 10 ** (_localDecimals - _sharedDecimals);\n    }\n\n    receive() external payable {\n        /// @dev Stargate will send ETH when we withdraw from Stargate ETH pool.\n        /// So convert ETH to WETH if ETH sender is not WETH contract.\n        IWETH _weth = weth();\n        if (msg.sender != address(_weth)) {\n            _weth.deposit{value: address(this).balance}();\n        }\n    }\n\n    function convertRate() public view returns (uint256) {\n        return _getStargateV2ETHStorage()._convertRate;\n    }\n\n    function weth() public view returns (IWETH) {\n        return _getStargateV2ETHStorage()._weth;\n    }\n\n    /**\n     * @dev Stargate has concept of sharedDecimals and localDecimals.\n     * The amount we supply is in localDecimals and stargate convert it into sharedDecimals and back.\n     * By doing this stargate removes dust from input amount.\n     * In case of native pool, stargate expects users to provide proper input and has an assert to enforce this.\n     * @param amountLD_ amount in local decimals\n     */\n    function _deDustAmount(uint256 amountLD_) internal view returns (uint256) {\n        uint256 _convertRate = convertRate();\n        // uint256 _amountSD = amountLD_ / convertRate;\n        // uint256 _amountLD = _amountSD * convertRate;\n        return (amountLD_ / _convertRate) * _convertRate;\n    }\n\n    /**\n     * @dev Stargate ETH strategy supports ETH as collateral and Vesper deals\n     * in WETH. Hence withdraw ETH from WETH before depositing in Stargate pool\n     */\n    function _deposit(uint256 collateralAmount_) internal override {\n        collateralAmount_ = _deDustAmount(collateralAmount_);\n        if (collateralAmount_ > 0) {\n            weth().withdraw(collateralAmount_);\n            stargatePool().deposit{value: collateralAmount_}(address(this), collateralAmount_);\n        }\n    }\n}\n"
    },
    "contracts/strategies/Strategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IStrategy} from \"../interfaces/vesper/IStrategy.sol\";\nimport {IVesperPool} from \"../interfaces/vesper/IVesperPool.sol\";\nimport {ISwapper} from \"../interfaces/swapper/ISwapper.sol\";\n\n// solhint-disable no-empty-blocks\nabstract contract Strategy is Initializable, UUPSUpgradeable, IStrategy {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    error AddressIsNull();\n    error CanNotSweepToken();\n    error FeeCollectorNotSet();\n    error InvalidStrategy();\n    error NotEnoughAmountOut();\n    error Unauthorized();\n\n    event UpdatedFeeCollector(address oldFeeCollector, address newFeeCollector);\n    event UpdatedSwapper(ISwapper oldSwapper, ISwapper newSwapper);\n\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant MAX_UINT_VALUE = type(uint256).max;\n    /// @custom:storage-location erc7201:vesper.storage.Strategy\n    struct StrategyStorage {\n        IERC20 _collateralToken;\n        address _pool;\n        address _receiptToken;\n        address _feeCollector;\n        ISwapper _swapper;\n        EnumerableSet.AddressSet _keepers;\n        string _name;\n    }\n\n    bytes32 private constant StrategyStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getStrategyStorage() private pure returns (StrategyStorage storage $) {\n        bytes32 _location = StrategyStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __Strategy_init(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) internal onlyInitializing {\n        __UUPSUpgradeable_init();\n        if (pool_ == address(0) || swapper_ == address(0) || receiptToken_ == address(0)) revert AddressIsNull();\n        StrategyStorage storage $ = _getStrategyStorage();\n        $._pool = pool_;\n        $._collateralToken = IVesperPool(pool_).token();\n        $._receiptToken = receiptToken_;\n        // Set pool governor as default feeCollector\n        $._feeCollector = IVesperPool(pool_).governor();\n        $._swapper = ISwapper(swapper_);\n        $._name = name_;\n        $._keepers.add(msg.sender);\n    }\n\n    modifier onlyGovernor() {\n        if (msg.sender != governor()) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyKeeper() {\n        if (!_getStrategyStorage()._keepers.contains(msg.sender)) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyPool() {\n        if (msg.sender != pool()) revert Unauthorized();\n        _;\n    }\n\n    function collateralToken() public view override returns (IERC20) {\n        return _getStrategyStorage()._collateralToken;\n    }\n\n    function feeCollector() public view returns (address) {\n        return _getStrategyStorage()._feeCollector;\n    }\n\n    function governor() public view returns (address) {\n        return IVesperPool(pool()).governor();\n    }\n\n    function isActive() external view override returns (bool) {\n        (bool _isActive, , , , , , , , ) = IVesperPool(pool()).strategy(address(this));\n        return _isActive;\n    }\n\n    /// @notice Check whether given token is reserved or not. Reserved tokens are not allowed to sweep.\n    function isReservedToken(address token_) public view virtual override returns (bool) {\n        return token_ == receiptToken() || token_ == address(collateralToken());\n    }\n\n    /// @notice Return list of keepers\n    function keepers() external view override returns (address[] memory) {\n        return _getStrategyStorage()._keepers.values();\n    }\n\n    function NAME() external view returns (string memory) {\n        return _getStrategyStorage()._name;\n    }\n\n    function pool() public view override returns (address) {\n        return _getStrategyStorage()._pool;\n    }\n\n    function poolAccountant() external view returns (address) {\n        return IVesperPool(pool()).poolAccountant();\n    }\n\n    function swapper() public view returns (ISwapper) {\n        return _getStrategyStorage()._swapper;\n    }\n\n    function receiptToken() public view virtual override returns (address) {\n        return _getStrategyStorage()._receiptToken;\n    }\n\n    /// @notice Returns total collateral locked in the strategy\n    function tvl() external view virtual returns (uint256);\n\n    function VERSION() external pure virtual override returns (string memory) {\n        return \"5.5.0\";\n    }\n\n    /**\n     * @notice onlyGovernor: Add given address in keepers list.\n     * @param keeperAddress_ keeper address to add.\n     */\n    function addKeeper(address keeperAddress_) external onlyGovernor {\n        _getStrategyStorage()._keepers.add(keeperAddress_);\n    }\n\n    /// @dev OnlyKeeper: Approve all required tokens\n    function approveToken(uint256 approvalAmount_) external onlyKeeper {\n        _approveToken(approvalAmount_);\n    }\n\n    /// @notice OnlyKeeper: Claim rewards from protocol.\n    /// @dev This function will only be used when protocol doesn't offer claim by anyone.\n    function claimRewards() external onlyKeeper {\n        _claimRewards();\n    }\n\n    /**\n     * @notice OnlyKeeper: Rebalance profit, loss and investment of this strategy.\n     *  Calculate profit, loss and payback of this strategy and realize profit/loss and\n     *  withdraw fund for payback, if any, and submit this report to pool.\n     * @return _profit Realized profit in collateral.\n     * @return _loss Realized loss, if any, in collateral.\n     * @return _payback If strategy has any excess debt, we have to liquidate asset to payback excess debt.\n     */\n    function rebalance() external onlyKeeper returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        return _rebalance();\n    }\n\n    /**\n     * @notice onlyGovernor: Remove given address from keepers list.\n     * @param keeperAddress_ keeper address to remove.\n     */\n    function removeKeeper(address keeperAddress_) external onlyGovernor {\n        _getStrategyStorage()._keepers.remove(keeperAddress_);\n    }\n\n    /// @notice onlyKeeper:: Swap given token into collateral token.\n    function swapToCollateral(IERC20 tokenIn_, uint256 minAmountOut_) external onlyKeeper returns (uint256 _amountOut) {\n        StrategyStorage storage $ = _getStrategyStorage();\n        IERC20 _collateralToken = $._collateralToken;\n        address _swapper = address($._swapper);\n\n        if (address(tokenIn_) == address(_collateralToken) || isReservedToken(address(tokenIn_)))\n            revert CanNotSweepToken();\n        uint256 _collateralBefore = _collateralToken.balanceOf(address(this));\n        uint256 _amountIn = tokenIn_.balanceOf(address(this));\n        if (_amountIn > 0) {\n            if (_amountIn > tokenIn_.allowance(address(this), _swapper)) {\n                // if needed, forceApprove will set approval to zero before setting new value.\n                tokenIn_.forceApprove(_swapper, MAX_UINT_VALUE);\n            }\n            _swapExactInput(address(tokenIn_), address(_collateralToken), _amountIn);\n        }\n        _amountOut = _collateralToken.balanceOf(address(this)) - _collateralBefore;\n        if (_amountOut < minAmountOut_) revert NotEnoughAmountOut();\n    }\n\n    /**\n     * @notice onlyKeeper: sweep given token to feeCollector of strategy\n     * @param fromToken_ token address to sweep\n     */\n    function sweep(address fromToken_) external override onlyKeeper {\n        address _feeCollector = feeCollector();\n        if (_feeCollector == address(0)) revert FeeCollectorNotSet();\n        if (fromToken_ == address(collateralToken()) || isReservedToken(fromToken_)) revert CanNotSweepToken();\n        if (fromToken_ == ETH) {\n            Address.sendValue(payable(_feeCollector), address(this).balance);\n        } else {\n            uint256 _amount = IERC20(fromToken_).balanceOf(address(this));\n            IERC20(fromToken_).safeTransfer(_feeCollector, _amount);\n        }\n    }\n\n    /**\n     * @notice onlyGovernor: Update fee collector\n     * @param feeCollector_ fee collector address\n     */\n    function updateFeeCollector(address feeCollector_) external onlyGovernor {\n        if (feeCollector_ == address(0)) revert AddressIsNull();\n        StrategyStorage storage $ = _getStrategyStorage();\n        emit UpdatedFeeCollector($._feeCollector, feeCollector_);\n        $._feeCollector = feeCollector_;\n    }\n\n    /**\n     * @notice onlyGovernor: Update swapper\n     * @param swapper_ swapper address\n     */\n    function updateSwapper(ISwapper swapper_) external onlyGovernor {\n        if (address(swapper_) == address(0)) revert AddressIsNull();\n        StrategyStorage storage $ = _getStrategyStorage();\n        emit UpdatedSwapper($._swapper, swapper_);\n        $._swapper = swapper_;\n    }\n\n    /**\n     * @notice onlyPool: Withdraw collateral token from end protocol.\n     * @param amount_ Amount of collateral token\n     */\n    function withdraw(uint256 amount_) external override onlyPool {\n        StrategyStorage storage $ = _getStrategyStorage();\n        IERC20 _collateralToken = $._collateralToken;\n        address _pool = $._pool;\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        if (_collateralHere >= amount_) {\n            _collateralToken.safeTransfer(_pool, amount_);\n        } else {\n            _withdrawHere(amount_ - _collateralHere);\n            // Do not assume _withdrawHere() will withdraw exact amount. Check balance again and transfer to pool\n            _collateralHere = _collateralToken.balanceOf(address(this));\n            _collateralToken.safeTransfer(_pool, Math.min(amount_, _collateralHere));\n        }\n    }\n\n    function _approveToken(uint256 amount_) internal virtual {\n        StrategyStorage storage $ = _getStrategyStorage();\n        $._collateralToken.forceApprove($._pool, amount_);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyGovernor {}\n\n    function _claimRewards() internal virtual {}\n\n    function _rebalance() internal virtual returns (uint256 _profit, uint256 _loss, uint256 _payback);\n\n    function _swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) internal returns (uint256 _amountOut) {\n        _amountOut = swapper().swapExactInput(tokenIn_, tokenOut_, amountIn_, 1, address(this));\n    }\n\n    function _trySwapExactInput(address tokenIn_, address tokenOut_, uint256 amountIn_) internal returns (uint256) {\n        try swapper().swapExactInput(tokenIn_, tokenOut_, amountIn_, 1, address(this)) returns (uint256 _amountOut) {\n            return _amountOut;\n        } catch {\n            return 0;\n        }\n    }\n\n    // These methods must be implemented by the inheriting strategy\n    function _withdrawHere(uint256 amount_) internal virtual;\n}\n"
    },
    "contracts/strategies/yearn/Yearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {IYToken} from \"../../interfaces/yearn/IYToken.sol\";\n\n/// @title This strategy will deposit collateral token in a Yearn vault and earn interest.\ncontract Yearn is Strategy {\n    using SafeERC20 for IERC20;\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.Yearn\n    struct YearnStorage {\n        uint256 _yTokenDecimals;\n    }\n\n    bytes32 private constant YearnStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.Yearn\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getYearnStorage() internal pure returns (YearnStorage storage $) {\n        bytes32 _location = YearnStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        string memory name_\n    ) external initializer {\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n\n        _getYearnStorage()._yTokenDecimals = 10 ** IYToken(receiptToken_).decimals();\n    }\n\n    function tvl() external view override returns (uint256) {\n        return _getCollateralFromYearn() + collateralToken().balanceOf(address(this));\n    }\n\n    function yToken() public view returns (IYToken) {\n        return IYToken(receiptToken());\n    }\n\n    function yTokenDecimals() internal view returns (uint256) {\n        return _getYearnStorage()._yTokenDecimals;\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        collateralToken().forceApprove(address(yToken()), amount_);\n    }\n\n    function _convertToShares(uint256 collateralAmount_) internal view returns (uint256) {\n        return (collateralAmount_ * yTokenDecimals()) / yToken().pricePerShare();\n    }\n\n    function _getCollateralFromYearn() internal view returns (uint256) {\n        IYToken _yToken = yToken();\n        return (_yToken.balanceOf(address(this)) * _yToken.pricePerShare()) / yTokenDecimals();\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _getCollateralFromYearn() + _collateralHere;\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        _pool.reportEarning(_profit, _loss, _payback);\n\n        // strategy may get new fund. deposit to generate yield\n        _collateralHere = _collateralToken.balanceOf(address(this));\n        if (_collateralHere > 0) {\n            yToken().deposit(_collateralHere);\n        }\n    }\n\n    function _withdrawHere(uint256 amount_) internal override {\n        IYToken _yToken = yToken();\n        uint256 _toWithdraw = Math.min(_yToken.balanceOf(address(this)), _convertToShares(amount_));\n        if (_toWithdraw > 0) {\n            _yToken.withdraw(_toWithdraw);\n        }\n    }\n}\n"
    },
    "contracts/strategies/yearn/YearnStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Strategy} from \"../Strategy.sol\";\nimport {IVesperPool} from \"../../interfaces/vesper/IVesperPool.sol\";\nimport {IYToken} from \"../../interfaces/yearn/IYToken.sol\";\nimport {IStakingRewards} from \"../../interfaces/yearn/IStakingRewards.sol\";\n\n/// @title This strategy will deposit collateral token in a Yearn vault and stake receipt tokens\n/// into staking contract to earn rewards and yield.\ncontract YearnStaking is Strategy {\n    using SafeERC20 for IERC20;\n\n    /// @custom:storage-location erc7201:vesper.storage.Strategy.YearnStaking\n    struct YearnStakingStorage {\n        IStakingRewards _stakingRewards;\n        IYToken _yTokenReward;\n        uint256 _yTokenDecimals;\n    }\n\n    bytes32 private constant YearnStakingStorageLocation =\n        keccak256(abi.encode(uint256(keccak256(\"vesper.storage.Strategy.YearnStaking\")) - 1)) & ~bytes32(uint256(0xff));\n\n    function _getYearnStakingStorage() internal pure returns (YearnStakingStorage storage $) {\n        bytes32 _location = YearnStakingStorageLocation;\n        assembly {\n            $.slot := _location\n        }\n    }\n\n    function initialize(\n        address pool_,\n        address swapper_,\n        address receiptToken_,\n        IStakingRewards stakingRewards_,\n        string memory name_\n    ) external initializer {\n        __Strategy_init(pool_, swapper_, receiptToken_, name_);\n\n        if (address(stakingRewards_) == address(0)) revert AddressIsNull();\n\n        YearnStakingStorage storage $ = _getYearnStakingStorage();\n        $._yTokenDecimals = 10 ** IYToken(receiptToken_).decimals();\n        $._stakingRewards = stakingRewards_;\n        $._yTokenReward = IYToken(stakingRewards_.rewardsToken());\n    }\n\n    function stakingRewards() public view returns (IStakingRewards) {\n        return _getYearnStakingStorage()._stakingRewards;\n    }\n\n    function tvl() external view override returns (uint256) {\n        return _getCollateralFromYearn() + collateralToken().balanceOf(address(this));\n    }\n\n    function yToken() public view returns (IYToken) {\n        return IYToken(receiptToken());\n    }\n\n    function yTokenDecimals() internal view returns (uint256) {\n        return _getYearnStakingStorage()._yTokenDecimals;\n    }\n\n    function yTokenReward() public view returns (IYToken) {\n        return _getYearnStakingStorage()._yTokenReward;\n    }\n\n    /// @notice Approve all required tokens\n    function _approveToken(uint256 amount_) internal override {\n        super._approveToken(amount_);\n        address _yToken = address(yToken());\n        collateralToken().forceApprove(_yToken, amount_);\n        IERC20(_yToken).forceApprove(address(stakingRewards()), amount_);\n    }\n\n    function _claimRewards() internal override {\n        // Claim reward and it will give us yToken as reward\n        stakingRewards().getReward();\n        IYToken _yTokenReward = yTokenReward();\n        uint256 _yRewardsAmount = _yTokenReward.balanceOf(address(this));\n        if (_yRewardsAmount > 0) {\n            // Withdraw actual reward token from yToken\n            _yTokenReward.withdraw(_yRewardsAmount);\n        }\n    }\n\n    function _convertToShares(uint256 collateralAmount_) internal view returns (uint256) {\n        return (collateralAmount_ * yTokenDecimals()) / yToken().pricePerShare();\n    }\n\n    function _getCollateralFromYearn() internal view returns (uint256) {\n        return (_getTotalShares() * yToken().pricePerShare()) / yTokenDecimals();\n    }\n\n    function _getTotalShares() internal view returns (uint256) {\n        return yToken().balanceOf(address(this)) + stakingRewards().balanceOf(address(this));\n    }\n\n    function _rebalance() internal override returns (uint256 _profit, uint256 _loss, uint256 _payback) {\n        IVesperPool _pool = IVesperPool(pool());\n        uint256 _excessDebt = _pool.excessDebt(address(this));\n        uint256 _totalDebt = _pool.totalDebtOf(address(this));\n\n        IERC20 _collateralToken = collateralToken();\n        uint256 _collateralHere = _collateralToken.balanceOf(address(this));\n        uint256 _totalCollateral = _getCollateralFromYearn() + _collateralHere;\n\n        if (_totalCollateral > _totalDebt) {\n            _profit = _totalCollateral - _totalDebt;\n        } else {\n            _loss = _totalDebt - _totalCollateral;\n        }\n        uint256 _profitAndExcessDebt = _profit + _excessDebt;\n        if (_profitAndExcessDebt > _collateralHere) {\n            _withdrawHere(_profitAndExcessDebt - _collateralHere);\n            _collateralHere = _collateralToken.balanceOf(address(this));\n        }\n\n        // Make sure _collateralHere >= _payback + profit. set actual payback first and then profit\n        _payback = Math.min(_collateralHere, _excessDebt);\n        _profit = _collateralHere > _payback ? Math.min((_collateralHere - _payback), _profit) : 0;\n        _pool.reportEarning(_profit, _loss, _payback);\n\n        // strategy may get new fund. deposit to generate yield\n        _collateralHere = _collateralToken.balanceOf(address(this));\n        IYToken _yToken = yToken();\n        if (_convertToShares(_collateralHere) > 0) {\n            _yToken.deposit(_collateralHere);\n        }\n\n        // Staking all yTokens to earn rewards\n        uint256 _sharesHere = _yToken.balanceOf(address(this));\n        if (_sharesHere > 0) {\n            stakingRewards().stake(_sharesHere);\n        }\n    }\n\n    function _withdrawHere(uint256 amount_) internal override {\n        // Check staked shares and shares here\n        IYToken _yToken = yToken();\n        uint256 _sharesRequired = _convertToShares(amount_);\n        uint256 _sharesHere = _yToken.balanceOf(address(this));\n        if (_sharesRequired > _sharesHere) {\n            // Unstake minimum of staked and required\n            IStakingRewards _stakingRewards = stakingRewards();\n            uint256 _toUnstake = Math.min(_stakingRewards.balanceOf(address(this)), (_sharesRequired - _sharesHere));\n            if (_toUnstake > 0) {\n                _stakingRewards.withdraw(_toUnstake);\n            }\n        }\n\n        // Withdraw all available yTokens. Reread balance as unstake will increase balance.\n        _sharesHere = _yToken.balanceOf(address(this));\n        if (_sharesHere > 0) {\n            _yToken.withdraw(_yToken.balanceOf(address(this)));\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}